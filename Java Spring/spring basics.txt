IoC : 
	제어의 역전
	스프링에만 국한되는 용어가 아니다.
	AppConfig 클래스가 IoC의 예시이다.
		기존의 프로그램에서는 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고 연결하고 실행했다.
		즉 구현 객체가 프로그램의 제어 흐름을 스스로 조종했다.
		하지만 AppConfig이 등장한 뒤부터 구현 객체는 자신의 로직을 실행하는 역할만 담당하고 프로그램에 대한 제어 흐름은 AppConfig가 가져간다.
		이렇듯 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전이라고 한다.
		==> MemberService 인터페이스를 구현하는 MemberServiceImpl을 생성하는 AppConfig.

	프레임워크와 라이브러리의 차이가 IoC로 판가름나기도 한다.
		내 코드를 제어하고 대신 실행한다면 프레임워크이다.
		내 코드가 직접 제어의 흐름을 담당하면 라이브러리이다.

D.I : 

	의존관계 주입
	의존관계는 정적인 클래스 의존 관계와 동적인 객체(인스턴스) 의존 관계로 분리할 수 있다.
	클래스 의존 관계는 import 등으로 실행 전에도 쉽게 판단이 가능하다.(클래스 다이어그램)
	객체 의존 관계는 정적인 것이 아니다. 어플리케이션을 실행할 때마다 동적으로 바뀐다. (인스턴스 다이어그램)
		애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계이다.
	의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
		즉, 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.
	

IoC컨테이너와 DI 컨테이너 : 

	AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는 것을 IoC컨테이너 혹은 DI 컨테이너라고 한다.


	컨테이너 : 
		ApplicationContext를 스프링 컨테이너라고 한다.
		스프링 컨테이너는 @Configuration(AppConfig의 Config)이 붙은 AppConfig을 설정 정보로 사용한다.
		해당 클래스에서 @Bean이 붙은 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다.
		스프링 빈은 해당 어노테이션이 붙은 메서드의 이름을 그대로 가져와서 사용한다.
			따라서 applicationContext.getBean()의 parameter로는 AppConfig 클래스의 메서드 이름을 그대로 넘기면 된다. 

Bean과 컨테이너 : 

	스프링 빈과 컨테이너에 관련된 인터페이스의 계층구조는 다음과 같다.
	최상위에 BeanFactory, 이것을 구현하는 ApplicationContext, 또 이것의 하위에 AnnotationConfigApplicationContext가 있다.
	BeanFactory :
		스프링 컨테이너의 최상위 인터페이스이다. 
		스프링 빈을 관리하고 조회하는 기능이 들어있다. (getBean 등)
	ApplicationContext : 
		BeanFactory의 기능을 모두 상속받아서 제공한다.
		BeanFactory와의 차이점은 빈을 관리하고 조회하는 기능 뿐만 아니라 수많은 부가기능을 제공하는 것.
Canonical cover
	
	함수 종속관계를 확인해야 하는경우가 있다.
	정말 쉽게 얘기하면 함수 종속 관계를 축약하여 종속관계 확인의 비용을 줄이기 위한 것이다.
	쳐낼 수 있는 요소들을 쳐낸다는 개념.

	ex) when A->B , B->C, A->C holds, then A->C is redundant : transitivity에 의해 추론할 수 있기 때문.
	ex) RHS(A->B, B->C, A->CD) 이면
		A->B, B->C, A->D 로 간소화될 수 있다. (A->C는 유추될 수 있으니 생략. 그럼 A->D는?)
	A->CD에서 A->D가 나오는 이유는 decomposition rule에 의해서기도 하고, 교수님은 그냥 저런 상황에서 C를 드랍해도 성립한다고 하셨다.
	ex) LHS(A->B, B->C, AC->D) 이면
		마찬가지로 A->B, B->C, A->D로 간소화될 수 있는데, 앞의 FD에서 A->C가 유추되고, 여기서 C는 A에 지배됨을 알 수 있다.
		따라서 AC->D라는 FD에서 C는 A에 지배되기 때문에 쳐내도 무방하다고 하고, 그렇기에 A->D가 유추될 수 있다.
	
	★우리가 전 시간에 F로부터 유도될 수 있는 모든 FD들을 추가한 것을 F의 closure로서 F+라고 표현했다면,
	F의 canonical cover는 F로부터 쳐낼 것들은 다 쳐내고 최대한 간소화시킨 것을 말하고, Fc로 표현한다.

	
	Extraneous attributes : 간소화되지 않은 attribute들?

	A는 이럴 때 a에서 extraneous다 : a(알파) -> b(베타)라는 함수적 종속관계가 있다고 생각해보자. 
	일단 A는 a에 포함되어야 한다.
	(a-A) -> b (알파에서 A를 차집합)라는 함수적 종속관계와 F-(a->b) (F에서 a->b라는 FD를 빼버림) 라는 함수적 종속관계로 나눴을 때
	A를 빼도 기존에 있던 함수적 종속관계로 충분히 유추해낼 수 있을 때 그것을 A가 a에서 Extraneous 하다고 한다.
	(※ 즉! 빼도 된다!)

	A는 이럴 때 b에서 Extraneous다 : A가 b(베타)에 포함이 돼있고 아까랑 비슷한 맥락으로 F-(a->b)와 a->(b-A)로 나누었을 때
	마찬가지로 기존의 함수적 종속관계로 유추해낼 수 있다면 그것을 A가 b에서 Extraneous하다고 할 수 있다. 
	
		즉 주저리주저리 말이 길었는데, 요점은 알파 혹은 베타에 포함된 subset 중에 그것을 빼버려도 나중에 다시 유추할 수 있느냐,
		함수적 종속관계와 그것이 가리키는 연관성에 영향을 주지 않느냐 라고 헸을 때 아무런 영향 없이 뺄 수 있는 것이라면
		Canonical cover의 목표에 따라 제거하기 위해 이렇게 장황하게 설명하신 것 같다.

		ex) F = (A->C, AB->C)
			여기서 B가 AB->C의 Extraneous이다. 위에서 a(알파)에 해당되는 예제인데, AB를 a, C를 b라고 보면
			F->(a->b)는 여기서 A->C가 된다. (위의 F에서 AB->C를 빼면 남음)
			그리고 (a-A)->b의 결과는 AB에서 B를 빼버리게 되니까 A->C가 된다.
			그리고 이 두개를 합집합(Union) 하면 A->C가 된다.
			★여기서 F에서 logical하게 A->C를 확인할 수 있으면 B는 AB->C의 Extraneous임을 알 수 있다.
			여기서는 F가 A->C를 포함하고 있기 때문에 사실임을 알 수 있다.  
				(저렇게 직접 담는 것이 아니라 유추되는 경우에도 Extraneous하다고 할 수 있나?)
					==> 아래 예제를 통해 그렇다는 걸 확인할 수 있다. 
		ex) F = (A->C, AB->CD)
			여기서 C는 AB->CD에서 Extraneous이다.
			a->(b-A)에 의해 AB->D가 나오게 되고, F-(a->b)에 의해 A->C가 나오게 된다.
			(여기서 분명히 유니온을 해야되는데....왜 그냥 나눈 것만 생각하시지...?)
				==> 합집합이 두개를 같이 고려하라는 뜻인 것 같다.
			여튼 A->C에 의해서 C는 A에게 지배되고, 그렇기 때문에 AB->CD에서 C를 drop해서 AB->D를 유추할 수 있다.
			따라서 C는 AB->CD, 거기서도 b에 Extraneous하다 라고 할 수 있다.

Testing if an attribute is extraneous
		
		FD의 집합 F에 a->b가 속하고, 그 중 a에 속하는 A는 다음의 경우에서 a에 대해 Extraneous하다.
			(a - A)+ : 알파에서 A를 뺀 attribute의 closure를 먼저 계산한다. 
			위의 결과로 나온 attribute의 집합이 b(베타)를 설명할 수 있다면 A는 a에 대해 Extraneous하다.
			즉 A는 없어도 된다.

		b에 속하는 A는 다음의 경우에서 b에 대해 Extraneous하다.
			F'(F 프라임) = {F - (a->b)} U {a - (b - A)} (이 식으로 부터 얻을 수 있는 새로운 FD의 집합)
			F'에 속하는 FD에 한해서만 a+를 계산한다. (즉 a+의 계산 범위를 정해주는것)
			이 a+가 A를 포함한다면 A는 b에 대해 Extraneous하다.
			F'은 외워야 할 것 같다.

	★F라는 set이 있을 때 어떤 relation이 크다면 그 relation의 함수적 종속의 집합 F도 굉장히 커지고 복잡해지게 된다.
	그럴때 이 F를 직접 다루기보단 F의 성질을 변화하지 않고 가장 쉽게 다룰 수 있는 small set을 만드는 과정이 canonical cover라고 이해하자.
	
	F에 대한 Canonical cover Fc는 다음과 같은 성질을 만족한다.
		1. F로 Fc를 충분히 imply 할 수 있다.
		2. 그리고 반대로 Fc만 가지고도 F를 유추할 수 있다.
		3. Fc가 포함하는 모든 FD는 어떠한 Extraneous도 포함하지 않는다.
		4. Fc가 포함하는 모든 FD의 left side, 즉 a부분은 unique하다. 
			==> a1 -> b1
			       a1 -> b2 이런 FD가 없다는 뜻
	그러면 Fc를 대체 어떻게 찾냐
		쓰도코드로 알아보자.
			먼저 Fc를 최초에 F로 초기화한다.
			그리고 Fc를 돌면서 union rule을 시행한다.
			(4번에 해당하는 성질을 만족하기 위한 것. a1->b1, a1->b2이면 a1->b1b2로 만들어버려 4번도 만족하고 축약도 시킨다.)
			4번 조건에 위배되는 FD가 없게 되었다면 이제 Extraneous를 찾는다.
			a에 해당하는 Extraneous가 있는지, b에 해당하는 Extraneous가 있는지 차례차례 찾아본다.
			만약 발견이 되면 제거를 해준다. 
			이 과정이 계속 반복되며 특정 결과에 수렴을 하게 되면, 더 이상 연산의 결과로 아무런 변화도 없게 된다.
			그 결과가 바로 Fc이다. 

		ex) R = (A, B, C)
		     F = (A->BC, B->C, A->B, AB->C) 일때 위 알고리즘을 토대로 Fc를 찾아보자.
			1. A->BC와 A->B를 보면 left side가 중복된다. A->BC로 union rule을 시행한다.
			==> 이제 F는 A->B가 빠져 F = (A->BC, B->C, AB->C)가 된다.

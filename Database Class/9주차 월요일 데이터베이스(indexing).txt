indexing과 hashing

	인덱싱 : 색인을 만드는 것
		색인이란 원하는 데이터를 빨리 찾고자 할 때 쓰는 것
		검색이란 조건에 맞는 튜플을 찾는 것인데 이 검색 조건에 들어가는 attribute가 주로 기본키이긴 하지만 다 그렇진 않다.
	
	search key : 검색에 사용하는 attribute를 의미. 검색에 사용되는 모든 속성을 의미한다. 키 개념과는 다른 개념이다!
	index file : 인덱스는 테이블과는 별도의 데이터이다. 인덱스 파일은 인덱스 레코드 혹은 인덱스 엔트리로 이루어진다.
		인덱스 레코드는 테이블의 레코드와는 다른 개념임.

		인덱스 파일은 search key || pointer 의 형태로 이루어진다. 
		포인터는 search key에 해당하는 tuple을 가리킨다. 

	인덱슨느 2종류로 나뉜다
		ordered indices
		hash indices

	ordered index는 primary index, secondary index로 나눈다. 마찬가지로 키와는 별개의 개념이다.
	
		primary index : 테이블 파일 안에 튜플들이 저장된 순서가 인덱스의 엔트리들이 저장된 순서와 같으면 프라이머리 인덱스
			같지 않으면 스켄더리 인덱스라고 부른다. 

	dense index : 모든 튜플에 대해서 인덱스가 하나씩 있는 테이블?
	sparse index : 튜플들 중에서 일부에 대해서만 엔트리가 있는 경우.

		sparse 인덱스는 dense 인덱스에 비해 insert, delete할 때 약간의 작업이 더 필요하다.
		그리고 dense에 비해서 조금 느리다.

	sparse index는 서치 키를 기준으로 블럭을 형성한다. 그래서 모든 키를 인덱스로 등록하지 않아도 블럭의 범위를 체크하여 찾아낸다.

	멀티레벨 인덱스 : 테이블 안에 튜플이 너무 많아서 인덱스 테이블도 너무 커졌다. 이럴 경우 인덱스의 인덱스를 만든다.
		inner index와 outer index로 구분한다. 
	멀티레벨 인덱스는 sparse index이다. B+더 multilevel 인덱스이다.

	테이블에 어떤 변화가 생기면 그것을 인덱스에도 반영을 해줘야 한다.
		만약 insertion이 일어났다면 :
			Dense indices : 그냥 인덱스를 하나 넣어주면 된다.
			Sparse indices : 만약 블럭에 새로운 insertion에 대해서 자리?가 없다면 블럭을 두개로 쪼개고 새로운 
				엔트리를 만들어줘야 한다. 

		만약 deletion이 일어났다면 : 
			Dense indices : 그냥 인덱스를 지우면 된다. 
			Sparse indices : 블럭 내의 인덱스를 지운거면 그냥 지우면 되는데, 만약 블럭의 대표값을 지우게 될 경우
				다른 대표값을 찾아야 한다. 만약 10101을 지우면 이거보다 큰 값중에 가장 작은 값인 12121을 
				다음 대표값으로 지정해준다. 

				만약 블럭이 모두 비게되면 그 블럭은 버려도 된다. 블럭을 버릴 경우  그 블럭에 대한 엔트리도 지워주면 된다.
			  
	여기까지는 primary index

	secondary index : 
		반드시 dense index가 되어야 한다. 순서가 다르기 때문. 


	B+ tree (Multi-level의 대표적인 예)

	포인터 수의 적어도 절반은 사용해야된다? 
	서치키값이 트리의 키 값보다 작으면 왼쪽, 같거나 크다면 오른쪽으로 간다. - non-leaf node에서. 당연한 말이지?
	leaf-node에서는 값이 다른 지 같은 지만 본다. 만약 키 값이 같으면 왼쪽을 쫒아간다...? 
		leaf-node들은 다 연결이 되어있다. 각 리프노드의 포인터 부분은 다른 리프노드를 가리킨다.
		또 다른 중요한 특성은 리프 노드만 보면 키 값들이 모두 정렬되어있다.
			요약 : 리프노드끼리는 연결되어있고 그들의 키 값은 정렬되어있다. 
				리프노드만 봐도 키?를 다 찾을 수 있다.
	
	리프노드만 따졌을 때 secondary index이며 dense이다.
	 
	non-leaf만 보면 multilevel sparse index이다. 만약 테이블의 튜플이 K개이면 트리의 height는 ★log(2/n) k 이다.
		따라서 B+트리를 쓰면 검색 속도가 무지하게 빨라진다. 


	B+ 트리의 노드도 디스크 블럭으로 구현한다. (대게는 4KB를 많이 사용)
		ppt 18페이지 참고.
		B+트리를 쓰면 5번의 블록 access만 하면 됐다(height 4 + 실제 블럭 access 1)
			트리를 안쓰면 3만번 이상의 access가 필요하다.

	B+트리의 insertion과 deletion : 

		insertion : adams를 넣고싶으면 일단 adams에 대한 검색을 실시해야 한다. 
			검색을 통해 리프 노드를 찾고, 자리가 없으면 2개로 쪼갠다. 또 자리가 없으면 위로 올린다?

		delection : 마찬가지로 검색을 먼저 실시한다. 
			insertion deletion은 구글링으로 배우자....

		리프노드는 반드시 2개 이상 채워야 함. 만약 하나만 남았다면 뒤(포인터가 가리키는)의 노드와 합쳐야 한다. 
		이 과정에서 노드의 대표값(가장 앞에 있는 키)이 바뀔 수 있다. 대표값이 바뀌면 부모 노드도 대표값으로 바꿔야 한다.
			ppt에서 mozart와 kim 예시.

	
	B+ 트리 테이블과 테이블 파일(튜플들이 저장된 파일)은 별개다.]
	그런데 B+ 트리 파일은 이 두개가 합쳐진다. 기존의 B+ 트리 테이블에서 포인터가 들어간 부분에 그냥 튜플을 넣어서 참조 없이
		바로 매핑되는 형식.
	만약 search key의 길이가 고정되지 않고 가변적이라면? 
		* fanout : 포인터의 개수, 즉 서브노드의 개수

	prefix compression : 
		silas 와 silbers~~ 가 있다면 silb까지만 있어도 이 둘을 구분할 수 있다. 이것이 prefix compression
		

	Bulk loading

		aternative 1 : 솔팅하고 위에서부터 아래로 내려가는 형식인 듯.
		bottom-up building : 솔팅된 순서로 리프노드를 먼저 만들고 그 부모노드를 구성하는, 아래에서 위로 구성해가는 구성.
			속도가 굉장히 빠르다.


B tree

	B+트리에서는 리프노드에서 나왔던 값이 상위 노드에도 나타날 수 있었다.
	하지만 B트리에서는 그런 일이 없다. 모든 키 값은 한번만 나타난다. 
	== 공간이 절약된다. 
		그리고 B+트리에서는 search가 이루어질 때 반드시 리프노드 레벨까지 내려와야 된다.
		하지만 B트리에서는 리프노드 레벨에 내려오지 않아도 검색이 끝날 수 있어 빠르다.

	그렇다면 단점은?
		리프노드 레벨까지 내려가지 않아도 검색이 끝나는 경우는 드물다고 한다. == 속도 차이 기대하기 힘듦
		insertion 과 deletion 알고리즘이 굉장히 복잡해진다. 
			알고리즘이 복잡하니 버그가 늘어날 수 있고 디버그도 힘들어질 수 있다.
		★B+트리는 모든 키가 sorting된 순서로 리프노드에 다 있다. 따라서 모든 키를 보고싶다면 리프노드만 보면 되지만
		B트리는 리프노드에 모든 값이 있지 않아서 상위 노드를 왔다갔다 하며 찾아야 한다. 

		★range query : 어떤 범위를 주고 그 범위 안에서 무언가를 찾는 것. 채팅창에 쓰셨다.
			이 range query를 할때는 B+트리를 사용한다.  
		★지금은 hash index와 B+ tree만 사용한다.

	dept_name과 salary를 묶어서 composite search key를 만들 때 어느 키를 먼저 비교할 것인지에 따라 달라져야 한다.
		
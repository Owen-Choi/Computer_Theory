indexing과 hashing

	인덱싱 : 색인을 만드는 것
		색인이란 원하는 데이터를 빨리 찾고자 할 때 쓰는 것
		검색이란 조건에 맞는 튜플을 찾는 것인데 이 검색 조건에 들어가는 attribute가 주로 기본키이긴 하지만 다 그렇진 않다.
	
	search key : 검색에 사용하는 attribute를 의미. 검색에 사용되는 모든 속성을 의미한다. 키 개념과는 다른 개념이다!
	index file : 인덱스는 테이블과는 별도의 데이터이다. 인덱스 파일은 인덱스 레코드 혹은 인덱스 엔트리로 이루어진다.
		인덱스 레코드는 테이블의 레코드와는 다른 개념임.

		인덱스 파일은 search key || pointer 의 형태로 이루어진다. 
		포인터는 search key에 해당하는 tuple을 가리킨다. 

	인덱슨느 2종류로 나뉜다
		ordered indices
		hash indices

	ordered index는 primary index, secondary index로 나눈다. 마찬가지로 키와는 별개의 개념이다.
	
		primary index : 테이블 파일 안에 튜플들이 저장된 순서가 인덱스의 엔트리들이 저장된 순서와 같으면 프라이머리 인덱스
			같지 않으면 스켄더리 인덱스라고 부른다. 

	dense index : 모든 튜플에 대해서 인덱스가 하나씩 있는 테이블?
	sparse index : 튜플들 중에서 일부에 대해서만 엔트리가 있는 경우.

		sparse 인덱스는 dense 인덱스에 비해 insert, delete할 때 약간의 작업이 더 필요하다.
		그리고 dense에 비해서 조금 느리다.

	sparse index는 서치 키를 기준으로 블럭을 형성한다. 그래서 모든 키를 인덱스로 등록하지 않아도 블럭의 범위를 체크하여 찾아낸다.

	멀티레벨 인덱스 : 테이블 안에 튜플이 너무 많아서 인덱스 테이블도 너무 커졌다. 이럴 경우 인덱스의 인덱스를 만든다.
		inner index와 outer index로 구분한다. 
	멀티레벨 인덱스는 sparse index이다. B+더 multilevel 인덱스이다.

	테이블에 어떤 변화가 생기면 그것을 인덱스에도 반영을 해줘야 한다.
		만약 insertion이 일어났다면 :
			Dense indices : 그냥 인덱스를 하나 넣어주면 된다.
			Sparse indices : 만약 블럭에 새로운 insertion에 대해서 자리?가 없다면 블럭을 두개로 쪼개고 새로운 
				엔트리를 만들어줘야 한다. 

		만약 deletion이 일어났다면 : 
			Dense indices : 그냥 인덱스를 지우면 된다. 
			Sparse indices : 블럭 내의 인덱스를 지운거면 그냥 지우면 되는데, 만약 블럭의 대표값을 지우게 될 경우
				다른 대표값을 찾아야 한다. 만약 10101을 지우면 이거보다 큰 값중에 가장 작은 값인 12121을 
				다음 대표값으로 지정해준다. 

				만약 블럭이 모두 비게되면 그 블럭은 버려도 된다. 블럭을 버릴 경우  그 블럭에 대한 엔트리도 지워주면 된다.
			  
	여기까지는 primary index

	secondary index : 
		반드시 dense index가 되어야 한다. 순서가 다르기 때문. 


	B+ tree

	포인터 수의 적어도 절반은 사용해야된다? 
	서치키값이 트리의 키 값보다 작으면 왼쪽, 같거나 크다면 오른쪽으로 간다. - non-leaf node에서. 당연한 말이지?
	leaf-node에서는 값이 다른 지 같은 지만 본다. 만약 키 값이 같으면 왼쪽을 쫒아간다...? 
		leaf-node들은 다 연결이 되어있다. 각 리프노드의 포인터 부분은 다른 리프노드를 가리킨다.
		또 다른 중요한 특성은 리프 노드만 보면 키 값들이 모두 정렬되어있다.
			요약 : 리프노드끼리는 연결되어있고 그들의 키 값은 정렬되어있다. 
				리프노드만 봐도 키?를 다 찾을 수 있다.
	
	리프노드만 따졌을 때 secondary index이며 dense이다.
	 
	non-leaf만 보면 multilevel sparse index이다. 만약 테이블의 튜플이 K개이면 트리의 height는 ★log(2/n) k 이다.
		따라서 B+트리를 쓰면 검색 속도가 무지하게 빨라진다. 


	B+ 트리의 노드도 디스크 블럭으로 구현한다. (대게는 4KB를 많이 사용)
		ppt 18페이지 참고.
		B+트리를 쓰면 5번의 블록 access만 하면 됐다(height 4 + 실제 블럭 access 1)
			트리를 안쓰면 3만번 이상의 access가 필요하다.

	B+트리의 insertion과 deletion : 

		insertion : adams를 넣고싶으면 일단 adams에 대한 검색을 실시해야 한다. 
			검색을 통해 리프 노드를 찾고, 자리가 없으면 2개로 쪼갠다. 또 자리가 없으면 위로 올린다?

		delection : 마찬가지로 검색을 먼저 실시한다. 
			insertion deletion은 구글링으로 배우자....

		리프노드는 반드시 2개 이상 채워야 함. 만약 하나만 남았다면 뒤(포인터가 가리키는)의 노드와 합쳐야 한다. 
		이 과정에서 노드의 대표값(가장 앞에 있는 키)이 바뀔 수 있다. 대표값이 바뀌면 부모 노드도 대표값으로 바꿔야 한다.
			ppt에서 mozart와 kim 예시.

	
	
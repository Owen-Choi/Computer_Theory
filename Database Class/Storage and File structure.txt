물리적 저장 장치는 여러가지가 있는데, 이것을 분류하는데 4가지 기준이 있다.

1. access 속도
2. 단위 데이터당 비용
3. 신뢰성
4. 지속성

신뢰성이라고 하는 것은 전원이 차단됐거나 시스템 고장이 발생했을 때 데이터의 상실이 일어나지 않는 것,
지속성은 기준에 따라서 저장장치를 크게 volatile(휘발성)과 non-volatile(비휘발성)로 나눈다.
휘발성은 전원이 끊어졌을 때 메모리의 내용이 없어지는 것이고 비휘발성은 그렇지 않은 것.
비휘발성은 2차 또는 3차 저장장치에 해당한다.

저장장치의 종류

	캐쉬  : 가장 빠르고 가장 비싸다. 휘발성이다. 캐쉬는 메인 메모리보다 CPU에 가까이 있는데,
		얼마나 가까이 있느냐에 따라 l1,l2,l3 캐쉬로 분류할 수 있다. 
		l1과 l2는 대개 CPU와 같은 칩 내부에 있고, 소프트웨어에 의해서가 아니라 시스템에 의해 관리된다.

	메인메모리 : 마찬가지로 휘발성이고 굉장히 빠르다.  메인 메모리는 굉장히 비싸서 용량이 적다.
	
	플래시 메모리 : 비휘발성 메모리로,  전원이 끊어져도 데이터가 남아있다. 특징은 한 곳에 데이터를 한번만 쓸 수 있다는 것.
		만약 동일한 위치에 데이터를 다시 쓰고 싶다면 erase를 해야하는데, 이는 속도도 느리고 회수에도 한계가 있다.
		그리고 한 부분만 지워지지 않고 넓은 영역이 지워진다. SSD에서 사용됨

	magnetic disk ; 비휘발성, 자성을 띈 디스크가 계속해서 회전하고 있고, 그 위에 데이터가 저장된다.
		가격이 싸고 용량이 크다. 데이터 access 속도는 메인 메모리에 비하여 수천배~수만배 느리다.
		
	optical storage(광학저장장치) : 비휘발성 3차 저장장치
		CD  rom, dvd, blueray 디스크 등. 데이터 쓰기가 불가능한데 가능한 것도 있다.

	tape storage : 비휘발성, sequential access. 용량은 매우 크다.


storage hierarchy에 따라 저장장치를 1차,2차,3차로 구분한다.
	1차(primary storage) : 휘발성이고 가장 빠르다. 캐쉬와 메인 메모리가 여기에 해당한다. 
	2차(secondary storage) : 비휘발성이고 1차에 비해 느리지만 그래도 빠르다. 플래쉬 메모리와 마그네틱 디스크가 이에 해당한다.
	3차(teriary storage) : 가장 아래에 위치, 비휘발성이고 대용량이며 속도가 느리다. 필요에 따라 탑재하거나 제거할 수 있다.
			광학저장장치, 테이프 저장장치 등이 해당한다.

마그네틱 디스크와 플래쉬 저장장치

	마그네틱 디스크 안에는 데이터가 저장되어 있는 하나 이상의 플래터가 있고, 이 플래터는 스핀들을 중심으로 회전하고 있다.
	하나의 플래터는 여러개의 동심원으로 이루어져 있는데 이 동심원을 트랙이라고 부른다.
	그리고 이 트랙은 다시 여러 개의 섹터로 나누어지고, 섹터는 data access의 기본 단위이다. 
	두개 이상의 플래터가 있는 경우에 동일한 위치의 트랙을 모아서 실린더라고 표현한다.
	arm의 맨 끝에 달려있는 read-writer 헤드로 데이터를 읽거나 쓴다.
	헤드는 하나의 트랙만 접근할 수 있어서 원하는 데이터가 있는 트랙으로 헤드가 옮겨가야 한다.
	데이터가 있는 트랙으로 이동하면 플래터가 돌아서 헤드 밑으로 데이터가 오는데, 그러면 데이터를 access할 수 있다. 
	섹터의 크기는 과거나 현재나 항상 512바이트로 동일하다. 

	Disk controller : 

		컴퓨터 시스템과 디스크 하드웨어간의 인터페이스. 각 섹터의 checksum을 추가적으로 저장.
		해당 섹터의 데이터가 에러 없이 저장되어 있는 지 확인하는데 사용됨. 

	Disk의 Performance : 
		Access time : 마그네틱 디스크의 성능은 Access time으로 측정한다.
			access time은 CPU로부터 읽기 또는 쓰기 요구가 들어온 시점부터 실제 데이터전송이 이뤄질 때 까지의
			시간이다. 이 Access time은 Seek time과 latency time으로 구성이 된다.
		Seek time : 원하는 트랙상으로 헤드가 이동하는 데 걸리는 시간.
			일반적인 disk의 경우 4-10 ms가 걸린다. 
		Rotational latency time : 
			플래터가 회전하여 원하는 섹터가 헤드 밑으로 오기까지의 시간이다.
			일반적인 disk의 경우 4-11 ms가 걸린다.
		데이터 전송률 (Data-transfer rate): 
			디스크의 성능을 측정하기 위한 다른 척도로 데이터 전송율이 있다.
			안쪽 트랙으로 갈수록 느려진다. 안쪽 트랙으로 갈수록 섹터의 개수가 줄어들기 때문이다.
		MTTF(Mean time to failure) : 
			고장 없이 디스크를 쓸 수 있는 시간. 또 다른 척도로 사용된다.
			

		디스크 access의 최소 단위는 섹터라고 설명을 했는데 실제 운영체제나 시스템에서는 성능을 위하여 디스크를 블록 단위로 access한다.
		블록은 동일한 트랙 상의 여러개의 연속된 섹터들로 구성되고 디스크와 메인 메모리 사이의 데이터 전송은 블록 단위로 이루어진다.
		하나의 블록은 여러개의 섹터로 구성되어 있으며 최소의 단위는 512B이고 일반적으로 4-16KB의 크기를 갖는다.
		블록 크기가 작을 수록 동일한 size의 access를 위해서 더 많은 블록을 전송해야 하고 블록이 커질수록 공간의 낭비가 
		발생할 가능성이 높아진다. 따라서 시스템 환경에 따라 적절한 사이즈를 찾아야 한다.

		Disk arm scheduling algorithm : 헤드의 이동이 최소화되게 만드는 알고리즘. 대표적으로 엘리베이터 알고리즘이 있음.
		Disk access 성능을 최적화하기 위해서 파일의 구조도 굉장히 중요하다.
			디스크 성능이 좋을려면 헤드의 움직임이 적어야한다. 파일의 구조가 이를 결정할 수 있음

	Flash
		SSD : 플래쉬 메모리를 동시에 여러개 사용, 플래쉬 저장장치 상의 데이터를 쓰기 위해서는 먼저 erase를 해야하는데
		erase는 속도가 느리다. 따라서 가능한 같은 곳에 데이터를 다시 쓰지 않는 것이 좋고, 이를 wear leveling이라고 한다.
		
	RAID
		Redundant Arrays of Independent Disks의 약자이다.
		즉 레이드는 여러개의 디스크를 모아 마치 하나의 디스크처럼 관리하고 사용하는 것이다.
		여러 디스크를 병렬로 사용함으로서 고영량과 고성능을 달성하고 데이터를 중복하여 저장함으로서 높은 신뢰성을 제공하고자 한다.
		중복을 통하여 신뢰성을 높일 수 있는데, 중복이란 원래 데이터 이외에 추가적인 데이터를 저장함으로서 디스크가 고장나도
		데이터를 복구할 수 있도록 하는 것. 
	
		Mirroring(혹은 Shadowing)은 모든 디스크를 이중화하는 것으로,  실제로 2개의 디스크로 하나의 논리적 디스크를 구성한다.
		모든 쓰기 작업은 두 디스크에 공통적으로 수행하고 읽기는 둘 중 하나만으로도 수행이 가능하다. 두 디스크 중 하나의 디스크가
		고장나더라도 다른쪽의 데이터로 바로 복구가 가능하다.
		만약 MTTF, 즉 디스크가 고장나지 않고 사용할 수 있는 시간이 10만 시간이고, MTTR, 즉 디스크를 수리하는데 드는 시간이
		10시간이라고 하면 데이터 손실이 발생할 수 있는 평균 시간은 5만 7천년이다. 
		즉 미러링을 이용하면 데이터의 손실이 전혀 발생하지 않는다고 볼 수 있다.
		
		parallelism : 병렬화
		
			병렬화를 통해서 성능을 향상시킬 수 있다. 
			병렬화의 주요 목표는 여러 디스크로 load를 분배함으로서 처리량을 늘리고 반응시간을 줄이는 것.
			병렬화를 위한 방법 : 
				bit-level striping 
					각 byte를 bit단위로 분리하여 각각을 서로 다른 디스크로 저장하는 방식.
					즉 8개의 디스크로 array를 구성하여 i번째 디스크에 i번째 비트를 저장한다.
					최대 8배의 성능향상을 기대할 수 있다. 
				block-level striping
					n개의 디스크가 있을 때 i번째 블록을 (i mod n) + 1번째 디스크에 저장하는 방법이다.
					서로 다른 블록에 대한 access는 그 블록들이 서로 다른 디스크에 있다면 동시에 병렬적으로 처리할
					수 있다. 또 많은 수의 블록에 대한 요구도 모든 디스크를 동시에 활용함으로서 빠르게 처리할 수 있다.

			RAID는 이 중복과 병렬화 두가지를 어떻게 조합하느냐에 따라서 몇개의 level로 구분된다.
				0,1,5 가 가장 널리 사용된다.
				RAID level 0 : block striping을 사용하고 데이터를 중복하여 저장하지 않는다. (미러링 x?)
				RAID level 1 : block striping과 함께 미러링을 수행한다. 쓰기 성능은 약간 떨어질 수 있지만 중요한 
					데이터의 저장에 사용한다.
				RAID level 5 : 분산 패리티를 이용한다. n+1개의 디스크가 있을 때
				 	n개의 디스크에는 데이터를, 1개의 디스크에는 패리티를 저장한다. 
					이때 패리티 정보는 하나의 디스크에만 저장되는 것이 아니라 여러 디스크에 분산되어 저장된다.
					패리티는 error correction bit, 오류 수정 비트를 저장하고 있다.

			여러가지 RAID 레벨 중에서 하나를 선택하기 위한 고려 사항은 몇가지가 있다.
			레이드 레벨 0는 데이터 안정성이 중요하지 않을 때만 사용될 수 있다.백업 수단이 있을 경우.
			레이드 레벨 1과 5는 레이드 내에서 복구가 가능한데 레벨 1이 더 많은 디스크를 사용함으로서 성능과 신뢰성을 더 높이는데
				사용될 수 있다. 
			레벨5는 업데이트가 덜 빈번하고 대용량의 데이터를 처리하는데 적절하다.
	
		레이드를 사용함에 있어서 몇가지 하드웨어적 고려사항이 있다.
			Latent failure는 성공적으로 저장된 데이터가 나중에 손상되는 것을 의미하고 이런 일이 발생하면 하나의 디스크에
				오류가 생기더라도 데이터의 손실로 이어질 수 있다. 이것을 찾기 위해 주기적으로 디스크를 scan하여야 하고
				필요한 경우에 복사본 혹은 패리티를 통하여 복구하여야 한다.
				이러한 작업을 Data scrubbing이라고 한다. 
			만약 디스크를 교체하여야 하는 경우에 전원을 끄고 교체해야 한다면 여러 문제가 발생할 수 있다.
			따라서 전원이 켜진 상태에서 교체가 필요한데 이를 Hot swapping이라고 한다. 
			또는 사전에 spare disk를 장착해두어 고장시에 바로 사용할 수 있다. 
	
	3차 저장장치

		비용이 싸고 용량이 매우 크나 속도가 매우 느리다.
		광학디스크, 마그네틱 테잎 등이 있다. 
		마그네틱 테잎의 드라이버 가격은 매우 비싸고 순차적 access만 가능하다.


	File Organization
		일반적으로 하나의 데이터베이스는 여러개의 테이블로 구성되고, 많은 데이터베이스 시스템에서 각 테이블은 하나의 파일로 저장된다.
		각 파일은 연속된 레코드로 구성되고 하나의 레코드는 연속된 필드로 구성된다. 여기에서 레코드는 튜플, 필드는 attribute에 대한 구조이다.
		레코드의 길이가 일정한 경우
		== 고정길이 레코드
			 길이를  r이라고 하면
			i번째 레코드는 r * (i-1)위치에 저장되게 된다.
			블록의 사이즈가 레코드 사이즈의 정수배가 아니라면 2개의 블록에 걸쳐서 저장된 레코드가 존재할 수도 있다.

		고정길이 레코드의 삭제 : 
			1. 삭제할 레코드의 뒤에 있는 모든 레코드를 하나씩 당기는 방법
			빈 곳 없이 레코드를 저장할 수 있는 장점이 있지만 레코드 수가 많아지면 오버헤드가 커진다.

			2. 삭제한 공간에 가장 마지막 레코드를 삽입하는 방법
			빈 곳 없이 레코드를 저장할 수 있는 장점이 있지만 레코드의 순서가 유지되지 않는다.

			3. 프리 리스트(Free list)
			일종의 링크드 리스트이고 파일 내의 빈곳들을 연결하고 있다. 
			새로운 데이터를 삽입할 때 링크드 리스트를 따라 빈 데이터가 있는 곳을 쉽게 찾아 저장할 수 있다. 
			장점은 레코드의 삭제 및 삽입이 매우 효율적이다.
			단점은 테이블 내에서 삭제되는 레코드가 많을 때 중간에 빈 공간이 많이 발생할 수 있다는 것.
			
		레코드의 길이가 변하는 경우
		==가변길이 레코드 
			실제 데이터베이스에서는 하나의 블록 내에 가변길이 레코드를 저장하는 경우가 많이 발생하는데]
			그 이유는 하나의 파일 내에 둘 이상의 테이블에 대한 레코드가 저장이 되거나 또는 테이블이 문자열과 같은
			가변 길이 attribute를 하나 이상 포함하기 때문이다. 
			
			(25,5) 의 의미는 25 index에 길이 5의 데이터가 들어간다는 뜻이다.
			Heap, Sequential, Hash organization은 뭔 소린지 정말 모르겠다. 


	Data dictionary : 시스템 카탈로그라고도 부르며 메타데이터를 저장한다.
		메타데이터로는 데이터베이스 내의 모든 테이블 정보가 있겠다. 
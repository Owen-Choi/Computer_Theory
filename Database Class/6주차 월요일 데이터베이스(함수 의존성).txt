join과 같은 combine schema, 즉 테이블을 combine하면 중복과 같은 문제가 생긴다.
즉 join으로 테이블을 합치는 디자인 방식은 여러 문제를 수반한다.
여기서 우리는 테이블을 더 크게 만들지 말고 작게 만들면 어떨까 라는 의문이 생긴다.(smaller schema)
decomposition : functional dependency(함수성 종속)
	테이블을 소분할 때 functional dependency가 도움이 된다.
	ex) schema(dept_name, building, budget), candidate key (dept_name)이라고 하면
		dept_name -> building, budget 으로 나타낼 수 있다.
		교수님 설명에 따르면 dept_name이 candidate key역할을 하고 있었는데 테이블을 합치면서(??)
		더 이상 candidate key의 역할을 하지 못하게 됐고, 그로 인해 building과 budget이 반복적으로 나타나게 되는
		결과가 나온 것이라고 한다. 무슨 말인지 이해는 감.
		위와 같은 관계를 함수성 종속이라고 한다.

함수성 종속에 의해 테이블을 작게 만드는 것이 항상 좋을까?
	아닐 수도 있다. Lossy decomposition(손실분해)	=> ppt 그림 참고, 분해하고 natural join을 다시 하면 결과가 이상하게 나온다.
	
	r(R) r은 relation이름, R은 속성들의 집합 : employee(ID, name ...) 
	
	lossless-join decomposition(무손실분해)
		만약 R = (A,B,C)을 R1(A,B), R2(B,C)로 소분했을 떄, 다시 자연조인했을 때 처음 릴레이션 R과 완벽히 똑같은 결과가 나와야
		무손실분해이다. 

Normalization(정규화)의 목표
	우리가 어떤 relation R을 가지고 있을 때 이 relation이 좋은 form이냐 하고 결정을 할 필요가 있다.
	만약에 R이 충분히 좋은 form을 가지고 있지 않다면 R을 분해를 해야한다.
	(중간에 숨어있는 함수적 종속관계가 있으면 데이터 중복이 발생할 수도 있고 충분히 좋은 form이 아니다.)
	또한 분해의 과정에서 함수적 종속관계가 깨지면 안된다. 
	
	정규화는 일반 정규화와 고급 정규화로 나뉜다.
		일반 정규화 : 
			(1NF, 2NF, 3NF, EKNF, BCNF(3.5NF)) 를 묶어 일반 정규화라고 한다.
		고급 정규화 : 
			(4NF, 5NF, 6NF)를 묶어 고급 정규화라고 한다. 

		1NF(FIRST NORMAL FORM)
			Domain이 atomic이어야 한다. 즉 complex attribute가 아니어야 한다. 
			바꿔말하면 만약 어떤 릴레이션 R이 1NF이면 R의 모든 attribute는 atomic하다고 생각하면 된다.

		교수님 설명에 따르면 만약 학생 전공과 번호를 알 수 있는 roll numbers라는 열이 있고, 포맷이 "CS100"과 같다면 
		컴퓨터 공학임을 알기 위해 CS, 번호를 알기위해 100 이렇게 두개로 분류하는 작업이 필요하다고 한다.
		이런 작업을 필요없게 만드는게 1NF의 기본적인 철학이라고 한다.
		

함수적 종속을 사용한 분해 (Decompostion using functional depencies)
	
	목표 : 특정한 릴레이션이 "좋은"형태를 띄게 하기 위해 (1NF에서 "좋은" 형태는 atomicity를 띄는 것. 이런 식으로 단계마다 목표가 다르다.)
	
	그럼 함수적 종속이 뭘까? 
		함수를 생각해보자. f:X -> Y : x에서 y로 가는 함수다. 그리고 함수는 X값에 따라 Y값이 달라진다. 이런 관계에 있는 것을 
		함수 관계에 있다고 말한다. 
		책의 예제를 생각해보면, dept_name에 따라서 building과 budget이 달라졌다. 이런 것을 함수관계에 있다고 한다.

		<추가 내용>
		어떤 테이블 R에 존재하는 필드의 부분집합을 각각 X와 Y라고 할 때, X의 한 값이 Y에 속한 오직 하나의 값에만 사상될 경우
		Y는 X의 종속함수라고 하며 X->Y라고 표기한다.
		예를 들어 테이블에 [생일]과 [나이]가 존재할 때, [나이]필드는 [생일]필드에 함수 종속이다. 생일을 알고있다면, 나이에 대한 
		필드를 참조하지 않거나 아예 필드를 유지하지 않아도 나이를 알 수 있기 때문.
		 
		만약 K가 r(R)의 super key라면 K -> R을 만족한다. 생각해보면 당연.

	함수적 종속은 어떤 방법으로 사용될 수 있을까
		릴레이션의 인스턴스가 주어진 함수종속의 집합 F를 만족시키는 지 검사하기 위해서 사용될 수 있음.
			예를 들어 A -> B, B -> C 라는 함수적 종속이 있다면 얘네를 다 모아놓은 것이 F.
		적법한 릴레이션의 집합에 대해 제약조건을 명시하기 위해서 사용하는 경우도 있음.
			F holds on R (F가 R을 보증한다)이라는 건 R의 모든 적법한 relation은 F의 함수적 종속을 만족한다는 뜻이다.
		
	Trivial : '하찮은' : 당연하다는 뜻이다. ID,name -> ID, name -> name이 이에 해당한다.
		일반적으로 B가 A에 속한다면 A -> B는 trivial이다.

	Closure : (0,1) = 0,1을 포함하지 않는 0과 1 사이의 값들
		[0,1] = 0,1을 포함하는 0 과 1 사이의 값들 = closure

		r(A,B,C)라는 릴레이션이 있고 A->B, B->C라는 함수적 종속을 가지고 있다고 생각하면 여기서 A->C 라는 함수적 종속을
		유추할 수 있다. 즉 이럴 경우 F {A->B, B->C}에서 F+ {A->B, B->C, A->C}가 된다. 그리고 이것을 F의 closure라고 하고,
		당연한 말이지만 F의 superset이 된다.

		+----------+-------------+----------+
		| building | room_number | capacity |
		+----------+-------------+----------+
		| Packard  |         101 |      500 |
		| Painter  |         514 |       10 |
		| Taylor   |        3128 |       70 |
		| Watson   |         100 |       30 |
		| Watson   |         120 |       50 |
		+----------+-------------+----------+
		여기서 functional dependency를 찾아보자.
		room_number -> capacity :  f1, 
		Building, room_number -> capacity : f2
		
		함수성 종속을 보여주는 첫 예제 : 
			위 릴레이션에서는 f1도 함수성 종속이 맞지만 시간이 지나고 여러 데이터가 삽입된다면 f1은 함수성 종속을 유지하기
			어려울 것이다. 따라서 f2로 building까지 묶어주어야 함수성 종속이 안정적이게 된다.


		
		
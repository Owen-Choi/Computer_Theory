Join : 
	select name, course_id from instructor, teaches
	where instructor.ID = teachs.ID;
		==> 여기서 ,(콤마)는 cartisian product의 역할을 한다고 함.
		카티션 프로덕트는 만약 A가 2개의 칼럼, B가 3개의 칼럼을 가지고 있다고 하면 A의 각 칼럼에 B의 모든 칼럼이 붙어
		총 6개의 행이 만들어지게 된다. 이렇게 되면 우리가 원하는 테이블이 나오지 않게 되므로 where절이 사용된다.
		instructor의 id와 teaches의 id가 같은 경우만 출력을 하기 때문에 우리가 원하는 결과를 얻을 수 있다.

	여기까지는 join 명령어를 사용하지 않은 경우이고, 이제 join 명령어를 사용하는 경우를 보자.
	select * from table1 join table2 on (search_condition)
		==> 조인의 경우 조건문이 where절이 아니라 on이 사용된다.
	select * from table1 join table2 using (join_column_list)
		==> 조인에 사용될 칼럼 리스트를 명시해줌.
		==> using은 반드시 괄호를 쳐줘야 한다고 한다!

		ex)
			select * from table1 INNER JOIN table2 ON table1.id = table2.id;
			select * from table1 LEFT JOIN table2 USING id;
			
		==> 두 가지 케이스 모두 같은 결과를 반환함. INNER JOIN, LEFT JOIN은 다음 페이지에 나오는데, Default, 즉 그냥 JOIN은 
		INNER가 생략된 경우로 INNER JOIN의 역할을 한다. 
			
			LEFT JOIN : 왼쪽 테이블의 모든 요소와 두 테이블의 교집합 요소를 함께 반환한다.
			RIGHT JOIN : 오른쪽 테이블의 ==
			FULL OUTER JOIN : 모든 테이블의 요소와 교집합 요소를 반환한다.

		natural join : 여태까지는 카티션 프로덕트를 사용하던 join을 사용하던 조건에 같은 칼럼을 가지는(student.id = takes.id)
			경우만을 고려하여 출력하였다. 이 기능을 해주는 것이 natural join이다. 네츄럴 조인을 사용하면, 동일한 컬럼이 있다면
			알아서 걔 기준으로 합쳐주는 것이 natural join이라고 한다. 
			즉 select * from student natural join takes; 라고 하면 알아서 ID열이 중복되는 것을 인식하고 이 열을 기준으로
			두 테이블을 합쳐서 출력해준다.

		view : 일반 사용자는 교수의 월급까지는 알 필요가 없다. 또한 데이터 베이스에는 여러가지 민감한 개인정보가 있을 수 있다.
			create view v as <query expression> : 기본적인 형식. v는 view의 이름이고, query expression은 select 절을 이용하여
			어떤 데이터를 포함할 지 등을 지정할 수 있다.
			view는 선언되고 실제로 만들어서져서 어딘가에 저장되어 있는 것이 아니라 정의만 저장되어있다가 실제 필요할 때
			그 정의에 따라 구성된다고 한다. 따라서 기존의 쿼리문을 통해 릴레이션을 새로 만드는 것과는 맥락이 좀 다르다고 한다.
				장점 : view를 사용하면 saving of an SQL statement, 원리는 잘 모르겠지만 속도가 약간 빨라진다고 하고
				가독성이 좋아진다는 특징이 있다고 한다. 
			ex) 
				create view faculty as select ID, name, dept_name from instructor;
				==> select name from faculty where dept_name = 'Biology';
			
			group by 이건 아직도 왜 쓰는 지 모르겠다. dept_name을 group by로 묶으면 한번에 dept_name이 한번씩만 나온다는데
			이게 distinct랑 다른 게 무엇일까.
				==> 아! CS라는 이름을 가진 dept가 여러개 있고, 그것들의 어떤 값을 더해서 표에 나타내야 할 때
				CS : 총합 이런 식으로 한번씩만 나와야 하니까 쓰는거구나.

			view로 테이블을 미리 만들어놓고 다시 불러와서 쓰는 개념. 잘 기억해두자.

			뷰의 정의를 위해 다른 뷰가 사용될 수도 있다. 만약 v1의 정의를 위해 v2가 사용됐다면, v1은 v2에 의존적이다(depend on)
			라고 할 수 있다. 자기 자신에게 의존하는 경우는 recursive 재귀적이라고 한다.
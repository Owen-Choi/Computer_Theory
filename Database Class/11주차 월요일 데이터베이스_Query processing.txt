쿼리 프로세싱
	
	쿼리 프로세싱은
	parsing and translation
	optimization
	evaluation
	3가지 단계로 이루어진다.

	parsing and translation을 통해 쿼리문을 관계대수식으로 바꾸고, 실제로 있는 값에 대한
	것인지 등을 검사한다.
	
	optimization은 관계대수 연산식을 계산하기 위한 가장 좋은 방법을 찾는 과정이다.
		Query optimization
			모든 관계대수 식 중에서 cost가 가장 적은 식을 선택하는 것.
			cost는 통계정보를 토대로 계산.(튜플의 개수, 크기 등)
	evaluation은 실행단계로, 앞의 두 단계를 거친 관계대수 연산식을 실행한다.
		실행은 항상 트리구조의 가장 아래 노드에서 루트 쪽으로 실행된다고 한다.

	Cost의 개념 : 
		블럭을 이동하는 시간이 tt, seek하는 시간이 ts이다.(일단은 두개만 있다고 가정)
	
	Selection Operation
		A1 : linear search
			장점 : selection 조건과 파일 내의 tuple들의 순서, index의 가용 여부에
				관계없이 사용할 수 있다.
			단점 : 테이블 전체, 또는 반을 읽어야 하므로 disk access 비용이 크다.
		
		 secondary index : 테이블 불러오기, 검색 키 attribute A값에 따라 정렬되어 있지
				않은 경우

		index scan
			A2(primary index, equality on key)
				검색키가 primary key인 경우에 대한 알고리즘이다.
				학번(기본키) = '12345' 와 같은 경우.
				cost는 (hi(B+트리의 height) + 1) * (tt + ts)이다.
				
			A3(primary index, equality on non-key)
				검색키가 primary key가 아닌 경우에 대한 알고리즘이다.
				학과 = '소프트웨어학과'와 같은 경우.
				{hi * (tt + ts)}(B+트리의 access cost) + ts + tt * b
			
			A4(secondary index, equality on non-key)
				검색키가 primary키가 아니지만 candidate key인 경우.
				A2 알고리즘과 비용이 동일하다.
				검색키가 candidate key가 아닌 경우.
				tuple들이 분산되어 저장되어있기 때문에 조건을 만족하는 
				튜플의 개수가 n개라면
				cost = (hi + n) * (tt + ts)로 굉장히 비싸다. 
		
		대소 비교에 대한 알고리즘
			A5(primary index, comparison)
				A>=V인 경우 인덱스를 이용해서 A>=V인 첫 값을 찾고
				그 다음부터 순서대로 scan하면 된다.
				A<=V인 경우 인덱스를 사용하지 않고 A>V인 튜플이 나올 때
				까지 scan한다.

			A6(secondary index, comparison)
				A5 알고리즘에서 entry와 pointer의 개념이 추가됨.
		
	여러개의 조건에 대한 selection 연산

		모든 조건이 and로 연결된 conjuntion 연산에 대해 : 
			A7(conjunctive selection using one index)
			A2-A6중에서 가장 비용이 적은 것을 고름.
			
			A8(conjunctive selection using composite index)
			composite index가 존재할 경우 그 index를 이용하여 A7 알고리즘과
			유사하게 처리한다고 함.

			A9(conjunctive selection by intersection of identifiers)
			여러 조건에 대하여 index를 이용할 수 있는 경우.
			index를 이용할 수 있는 각 조건을 만족하는 tuple들에 대해 pointer를
			모두 구하고 그 pointer들의 교집합을 구함. pointer들을 따라가 
			block을 access하면 disk IO가 발생하므로 tuple들 대신 pointer들의
			교집합을 구하는 것. 이렇게 구해진 pointer들을 이용해서 
			tuple들을 검사하고 나머지 조건들을 검사함!

		모든 조건이 or로 연결된 disjunction 연산에 대해 : 
			A10(disjunctive selection by union of identifiers)
				만약 모든 조건에 대하여 index가 있다면 인덱스를 이용하여
				각 조건을 만족하는 tuple들에 대한 pointer를 구하고 
				모든 pointer들의 합집합을 구하고 각각의 pointer를 따라가
				tuple들을 access 한다.
				하나의 조건이라도 index가 없다면 A1과 같이 전체 테이블을
				순차적으로 scan하여야 함.

	sorting : 

		대상 테이블에 대하여 B트리를 생성하고 단말 노드를 앞에서부터 순차적으로
		scan함으로서 sorting된 순서로 tuple들을 access할 수 있다.
		하지만 이러한 방법은 index를 생성하고 그 후에 각 tuple을 access 함에 있어서
		disk IO가 많이 발생할 수 있다는 단점이 있다. 
		메모리 내에 테이블이 모두 올라올 수 있다면 quick sort와 같은 효율적인 알고리즘
		을 사용할 수 있다. 하지만 테이블이 모두 올라오지 못한다면 external sort-merge
		알고리즘을 써야한다. 관련 시각자료 및 쓰도코드는 ppt 참고.

		결론적으로 external merge sort의 cost는 br(2[logM-1(br/M)] + 1)이다.
		
IoC : 
	제어의 역전
	스프링에만 국한되는 용어가 아니다.
	AppConfig 클래스가 IoC의 예시이다.
		기존의 프로그램에서는 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고 연결하고 실행했다.
		즉 구현 객체가 프로그램의 제어 흐름을 스스로 조종했다.
		하지만 AppConfig이 등장한 뒤부터 구현 객체는 자신의 로직을 실행하는 역할만 담당하고 프로그램에 대한 제어 흐름은 AppConfig가 가져간다.
		이렇듯 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전이라고 한다.
		==> MemberService 인터페이스를 구현하는 MemberServiceImpl을 생성하는 AppConfig.

	프레임워크와 라이브러리의 차이가 IoC로 판가름나기도 한다.
		내 코드를 제어하고 대신 실행한다면 프레임워크이다.
		내 코드가 직접 제어의 흐름을 담당하면 라이브러리이다.

D.I : 

	의존관계 주입
	의존관계는 정적인 클래스 의존 관계와 동적인 객체(인스턴스) 의존 관계로 분리할 수 있다.
	클래스 의존 관계는 import 등으로 실행 전에도 쉽게 판단이 가능하다.(클래스 다이어그램)
	객체 의존 관계는 정적인 것이 아니다. 어플리케이션을 실행할 때마다 동적으로 바뀐다. (인스턴스 다이어그램)
		애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계이다.
	의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
		즉, 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.
	

IoC컨테이너와 DI 컨테이너 : 

	AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는 것을 IoC컨테이너 혹은 DI 컨테이너라고 한다.


	컨테이너 : 
		ApplicationContext를 스프링 컨테이너라고 한다.
		스프링 컨테이너는 @Configuration(AppConfig의 Config)이 붙은 AppConfig을 설정 정보로 사용한다.
		해당 클래스에서 @Bean이 붙은 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다.
		스프링 빈은 해당 어노테이션이 붙은 메서드의 이름을 그대로 가져와서 사용한다.
			따라서 applicationContext.getBean()의 parameter로는 AppConfig 클래스의 메서드 이름을 그대로 넘기면 된다. 

Bean과 컨테이너 : 

	스프링 빈과 컨테이너에 관련된 인터페이스의 계층구조는 다음과 같다.
	최상위에 BeanFactory, 이것을 구현하는 ApplicationContext, 또 이것의 하위에 AnnotationConfigApplicationContext가 있다.
	BeanFactory :
		스프링 컨테이너의 최상위 인터페이스이다. 
		스프링 빈을 관리하고 조회하는 기능이 들어있다. (getBean 등)
	ApplicationContext : 
		BeanFactory의 기능을 모두 상속받아서 제공한다.
		BeanFactory와의 차이점은 빈을 관리하고 조회하는 기능 뿐만 아니라 수많은 부가기능을 제공하는 것.


ComponentScan과 의존관계 자동주입
	기존 @Configuration, @Bean과 AppConfig 파일을 이용한 스프링 빈 수동설정이 아니라 자동으로 스프링 빈을 등록해주는 방식이다.
	구현체들에 @Component를 붙이고 의존성 주입 관련 메서드 위에 @Autowired를 붙여서 자동 의존관계 주입을 해주면
	스프링 빈에 등록이 된다.
	
	@Configuration은 설정 파일을 따로 만들고 그 안에서 설정이 이루어진다면
	@ComponentScan은 구현체들에게 이를 위탁하는 것과 비슷하다.
	각 구현체들 내부에서 @Component, @Autowired 등을 통해 스프링 빈? 설정을 한 뒤에 AutoAppConfig 클래스에서 @ComponentScan으로
	이를 한번에 스캔하는 방식.

	컴포넌트 스캔 방식에서 스프링 빈의 기본 이름은 클래스 이름과 동일하되, 맨 앞글자만 소문자로 바꿔서 사용하도록 한다.
	이름을 직접 지정하고 싶다면 @Component("memberServiceImpl") 과 같이 지정하면 된다.

@Autowired

	생성자에 지정된 @Autowired가 자동으로 의존관계를 주입할때는 기본적으로 같은 타입의 스프링빈을 주입한다.

@Qualifier, @Primary
	
	스프링 빈을 조회할때 @Autowired는 빈을 type으로 조회한다. 즉 DiscountPolicy.class 와 같이 타입으로 조회하는데,
	이렇게 되면 해당 타입의 빈이 여러 개 있을 때 문제가 발생한다. 이것을 해결하기 위해서는 필드 명을 빈 이름으로 변경하거나
		(@Autowired
		   private DiscountPolicy rateDiscountPolicy : 빈 이름이 rateDiscountPolicy로 변경된다.)
	@Qualifier를 사용하거나
		(@Qualifier("mainDiscountPolicy"))
		(빈 이름이 변경되는 것이 아니라, 수정자 자동주입 등에서 이 Qualifier를 통해서 추가적으로 구분을 할 수 있게 된다.)
	@Primary를 사용할 수 있다.
		의미 그대로 우선권을 주는 것이다.

	활용 : 
	코드에서 자주 사용하는 메인 데이터베이스의 커넥션을 획득하는 스프링 빈이 있고, 코드에서 특별한
	기능으로 가끔 사용하는 서브 데이터베이스의 커넥션을 획득하는 스프링 빈이 있다고 생각해보자. 메인
	데이터베이스의 커넥션을 획득하는 스프링 빈은 @Primary 를 적용해서 조회하는 곳에서 @Qualifier
	지정 없이 편리하게 조회하고, 서브 데이터베이스 커넥션 빈을 획득할 때는 @Qualifier 를 지정해서
	명시적으로 획득 하는 방식으로 사용하면 코드를 깔끔하게 유지할 수 있다. 물론 이때 메인 데이터베이스의
	스프링 빈을 등록할 때 @Qualifier 를 지정해주는 것은 상관없다
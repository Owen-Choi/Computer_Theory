	tracert 명령어. 기억나지....?
	본명은 traceroute라고 한다.
	
	패킷손실 : 라우터의 버퍼가 꽉 찼을 때 들어온 정보들이 버려지면서 생김. 복습하고 가자.
	패킷손실은 무선 네트워크를 쓸 때 무선 링크의 물리적인 특성에 의해서 일어나기도 한다.
	
	Kbps의 bps는  byte per second가 아니라 bits per second다. 바이트가 되려면 B(대문자)가 온다.
	Mbps는 10의 6제곱 / Gbps는 10의 9제곱
	Mbps에 나누기 8을 하면 MBps가 된다. 기가나 키로로 마찬가지.

	Throughput : 처리율 ==> 두번 언급하시고 채팅창에도 치라고 하셨다. 느낌 오지?
	instantaneous throughput : 특정한 한 시간대의 처리율을 말함.
	average throughput : 긴 시간 동안의 처리율의 평균

	link capacity : 해당 링크는 이론적으로 최대 이만큼 보낼 수 있다 라는 뜻.
		물론 현실적으로 그 만큼의 throughput이 나오기는 어렵다. 용어 중요하다고 함.
		
	throughput과 보틀넥의 상관관계 알아두자. 앞의 link capacity가 크냐 뒤가 크냐 이런거.
		만약 link capacity가 Rc,Rs,Ri 이렇게 있다면 throughput은 이 셋중 가장 작은 값이 된다.
				==> 보틀넥
	
	서버, 호스트, 링크 이 세개중에 병목현상이 주로 일어나는 곳은? 서버쪽이다. 
	물론 호스트도 규모가 커진다면(기업, 기관) 호스트쪽이 bottleneck이 될수도 있다.
	
	TV처럼 up-link 가 필요없는 장치는 up-link capacity가 매우 적고 down link가 크다고 한다.

	Chapter1 84페이지 암기해야한다고 한다. 
	프로토콜 스택 : 5개의 계층으로 이루어져있고 이거 다 외우셈.
		application, transport, network, link, physical 이 5개 ㅇㅇ

	=====================================================


1장에서는 인터넷이 돌아가는 큰 그림을 살펴봄.
2강은 인터넷 5계층을 하나하나 살펴볼 예정.
		
	유저 어플리케이션을 만들 때 좋은 소식은 네트워크 코어 장치를 위한 소프트웨어는 만들 필요가 없다.
	그렇기 때문에 빠른 개발과 확산이 가능하다고 한다. 이 얼마나 좋은 소식인가! 
	
	Application 구조는 크게 2가지이다. 
		Client - Server
			잘 알지? 
		Peer to peer
			peer to peer는 따로 항상 켜져있는 서버를 두지는 않는다.
			client server 구조는 server에게 client가 데이터를 보내고, 다른 client가 그 server에 접근하여 통신이 이루어진다.
			하지만 p2p는 유저들끼리 통신이 이루어진다. 파일 교환도 서버에 있는 파일을 가져오는 것이 아니라
			유저들의 pc에 있는 분산된 파일을 긁어와?서 파일을 교환한다. 이건 이해가 잘 안되네.
			p2p는 self scalability로, 점점 커지는 구조를 가진다고 한다.
			하지만 p2p는 connection 관리가 정말 힘들다고 한다. 
		
	소켓 : 본질적으로는 파일포인터와 다를 것이 없다. 추상적인 개념인데, write 하고 read할 수 있는 창구라고 생각하면 된다.
		Addressing : 어떤 프로세스에서 만들어진 소켓과 다른 프로세스에서 만들어진 소켓을 서로 연결시켜줄려면
		주소를 인터넷을 타고 찾아가야 하는데 여기서 IP주소가 사용된다. 그리고 이것을 Addressing이라고 한다.
			(+ 포트번호까지가 어드레싱)
		ex : HTTP는 80번 포트로 고정. 따라서 웹서비스를 사용할때는 80이라는 포트를 따로 쳐줄 필요가 없다.
			메일 서버도 25번 포트로 동일한 개념		
		
		아파치 : PC를 웹서버로서 동작할 수 있게 해준다고 한다.
		 
			//첫번째 소켓 프로그래밍 과제 : 인터넷 계산기.

		semantic : 특정한 field들이 각각 어떠한 의미를 나타내는가 하는 것을 정하는 것을 semantic이라고 한다.
			즉 200은 OK, 300은 bad request 등. ==> 404 error!
	
		 syntax : 어떤 구조라고 하셨는데 제대로 안들었답...
		
		프로토콜을 정의할 때 : 누구나 볼 수 있는 공개 프로토콜(오픈 프로토콜 like HTTP)
			이 프로토콜에 맞게 프로그램을 구성한다면 기존의 서버와 문제없이 연동이 가능하다.
				회사에서 만든, 사유재산 같은 느낌의 프로토콜이 있다. (ex : skype)

		데이터 송수신의 대표적인 프로토콜 2가지 
			TCP/UDP
			
			TCP : TCP는 패킷손실이 일어나거나 순서가 뒤엉켜 도착하게 된다고 해도 어플리케이션이 그런 상황을
				못느끼게 알아서 OS차원 밑에서 복구를 한 다음 앱에 보낼 때는 원래 상태로 보낸다.
				하지만 네트워크 상태가 고르지 못한다면 이런 점 때문에 지연이 생길 수도 있다.
			UDP : 패킷 손실이 일어나면 손실이 일어난대로 그냥 간다.
			
			만약 에러를 조금 안고 가더라도 최소한의 지연으로 도착지까지 가는 서비스가 필요하다면
			UDP(ex : VOIP), 또 만약 예를들어 파일 전송과 같이 정확성이 정말 중요한 프로그램을 만들 경우에는 TCP를
			사용하는 등의 유동적인 판단이 필요하다. 
		
			온라인 슈팅게임 같은 경우는 UDP를 사용하는 것이 바람직할 것이다. 손실같은 경우는 뭐 다 방법이 있겠지.
			그리고 사실 UDP는 네트워크에서 말썽쟁이 역할을 할 가능성이 있다고 한다. UDP는 중간의 필터링 없이
			네트워크 링크에 들어가기 때문에 네트워크 코어에 큰 부담이 될 수도 있다. 하지만 TCP는OS에서 한번 걸러지기
			때문에 안정적이다. 몇몇 라우터는 방화벽에 의해 UDP가 들어오면 아예 드랍해버리는 경우도 있다고 한다.
			TCP/UDP의 특성과 유리한 상황 정도만 알아두면 되겠다.
			
			WebService : TCP를 쓰는 대표적인 서비스. 
				웹서비스를 가능하게 한 기술은 2가지이다.
					HTML + HTTP(데이터 전송기술)
					URL 관련 설명은 잘 못들음. 크게 중요하진 않아보인다. 

			HTTP : 기본적으로 loss가 있으면 안되는 프로토콜. 즉 TCP를 쓴다.
				소켓끼리 연결을 시켜주는건 HTTP가 아니다. TCP이다. TCP Connection을 맺어주는 것이 먼저다.
				HTTP의 경우 80번 포트로 요청이 들어오는데, 이 요청을 TCP가 먼저 맺어주고, HTTP로 request, response한다.
				그 후에  TCP를 닫는다.
					HTTP는 stateless이다. 이게 뭘까?
						만약 음료수를 다 먹고 리필 해주세요 라고 말하면 그 상태에서는 음료수가 한잔째인지
						두잔째인지 과거의 정보를 바탕으로 10잔 이상이면 안주는 등 response를 취한는 것을
						statefull이라고 한다. 즉 stateless는 그 반대. 과거의 정보를 기록해두지 않고 순간순간의
						response를 기계적으로 할 뿐. 이유는 웹 서버는 클라이언트가 너무너무 많기 때문이다.
						따라서 HTTP는 단순한 프로토콜이라고 함.
			HTTP connection
				www.someSchool.edu/SomeDepartment/ " home.index "
					==> "" : URL
				1단계 : TCP Connection을 OS가 맺어준다.
				2단계 : 연결이 맺어지면 서버가 HTTP에게 request를 보냄
				3단계 : 서버가 전송을 마치고 TCP 연결을 끊음.
				4단계 : HTTP가 request를 받음.
				==> 만약 다시 TCP 통신이 필요하다면 이 과정을 계속해서 반복한다. 물론 옛날 모델의 이야기고 지금은
					모르겠지만 여전히 표준은 이것과 같다고 한다.
			
			네트워크에서 딜레이를 나타내는 표현 : RTT(Round-trip time) : 시험에 무우조건 나옴
			RTT : Round-trip time : time for a small packet to travel from client to server and back
			HTTP connection예제에서는 (10번 + 1번 파일 보내야됨) = 22RTT
				==> 굉장히 비효율적 : 그래서 일반적으로 브라우저들은 TCP를 병행적으로 여는 것을 허용한다.
				이럴 경우 위의 예제는 4RTT가 된다.
					==> 하지만 이렇게 parallel하게 열어버리면 overhead가 걸려 부담이 된다.
					HTTP는 이 문제를 어떻게 풀었을까?
					==>  TCP connection을 끊지 않고 유지했다. 이것을 persistent HTTP라고 한다. (1.1버전 이후)
						추가적으로 유지된 TCP connection으로, 여러개의 오브젝트를 하나의 커넥션으로 보낼 수 있게 했다.
						그렇다면 언제 connection을 끊어줘야 할까? ==> 오랫동안 사용하지 않으면 끊음.

					
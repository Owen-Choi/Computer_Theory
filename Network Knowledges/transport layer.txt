transport layer는 뭐하는 layer일까

	쇼핑몰과 택배회사의 관계가 application과 transport의 관계와 비슷하다.
	어플리케이션이 보내고자 하는 데이터를 책임지고 보냄.

	transport layer는 밑에 있는 network layer를 이용해서 데이터를 보냄.
	TCP, UDP를 사용한다. 

	logical communication : 책같은 경우가 content라고 하면 이 책을 앞에서부터 읽으면서
		앞의 내용을 기반으로 뒷 페이지를 이해하고 이런 식으로 소화시킨다.
		두개의 클라이언트 서버 혹은 피어 투 피어 사이에서 둘 사이에 패킷을 문맥에 맞게
		문맥을 어기지 않으면서 제대로 전달되게 해주는 기능을 제공.

	transport layer는 logical communication을 제공한다.
	메세지(어플리케이션이 보낸 데이터)의 길이가 하나의 패킷에 담을 수 없을 정도로 크다면
	여러개의 패킷으로 segmentation한다. 

	호스트의 입장에서 하나의 어플리케이션에서만
	메세지가 나가는 것이 아니라 여러 개의 어플리케이션에서 메세지를 전송한다.
	이렇게 메세지가 섞여서 들어오는데 이것을 transport layer가 분류해준다?

	복원을 시키는 과정에서 문맥에 맞게 복원할 수 있게 정보를 같이 보낸다.
	transport layer에는 헤더부분에 로스나 순서의 섞임 등에 대응할 수 있게 sequence number와 같은
	정보를 첨부한다.

	네트워크 레이어는 receiver 쪽으로 데이터그램을 보내면 역할이 끝난다. 후에 receiver의 transport layer
	에서 어떤 응용프로그램으로 가는 지 결정을 해준다. 이것을(de-multiplexing)이라고 한다.
	
	TCP : 택배회사가 위탁함. 중간에 잃어버린 데이터는 알아서 찾아주고 순서도 맞춰서 받는
		사람에게 보내줌. 즉 TCP를 쓰면 데이터가 온다는 것은 전제하고 프로그램을 돌림.
	UDP : 가장 간단한 일만 함. 로스가 일어난 것에 대해선 후속처리를 하지 않고 기본적으로
		목적지와 보내는 어플리케이션, 받는 어플리케이션 등 만을 가지고 전송.
		중간에 잃어버리면 "유감"

		TCP/UDP 둘 다 delay guarantee, bandwidth guarantee는 제공해주지 못한다.

Multiplexing and demultiplexing

	어떤 세그먼트는 크롬에서 발생하고, 어떤 세그먼트는 서버에서 클라이언트로 가는 것이고,
	이렇게 다양한 어플리케이션으로부터 메세지가 나올 수 있는데 이런 정보들이 섞여서
	(통로가 하나기 때문에)나오는 것이 Multiplexing이고,
	이렇게 나온 메세지들의 목적지 정보를 보고 목적지 별로 추출하는것을 demultiplexing이라고 한다.
	즉 demultiplexing은 일종의 분류작업 

	이 demultiplexing을 어떻게 하고 있을까?
	sender 쪽에서 일어나는게 multiplexing, receiver쪽에서 일어나는 게 demultiplexing

	보내는 호스트의 IP주소와 포트번호를 헤더에 넣어주고, 받는 호스트의 IP주소와 받는 어플리케이션의
	포트 번호를 넣어주면 multiplexing과 demultiplexing이 가능하다. 

	★세그먼트는 패킷의 헤더에 어플리케이션을 구분할 수 있게 어플리케이션의 포트번호가 추가된 것이다.
	
	ppt 3-18은 ㅈㄴ 당연한 내용이니까 그냥 넘어갈께?
	udp는 자신의 포트번호와 목적지의 포트번호만 있으면 demultiplexing이 가능하다.
	udp의 경우 목적지의 포트 번호가 같아도 문제가 일어나지 않는다고 한다.
	

	tcp는 조금 복잡하다. tcp에서는 먼저 포트를 잡아놓고 누군가의 연결을 기다리는 쪽이 서버였다.
	서버쪽에서는 클라이언트가 오면 안쓰는 포트번호를 새로 할당해준다. 어플리케이션은 그 포트번호를 모르지만
	운영체제가 이 포트번호를 계속 관리한다.
	따라서 응용프로그램은 포트번호를 모르기 때문에 처음에 쓰였던 포트번호로 신호를 보낸다.
	처음에 welcome socket에 할당된 포트번호는 뒤에서 계속 쓰인다. 

	ppt - 20
	그리고 UDP처럼 목적지 정보만 보낸다면 어디서 온 정보인지 구분을 할 수가 없어 demultiplexing가 불가능하다.
	따라서 source port number도 같이 줘야한다. 하지만 만약 9157이라는 포트가 2개로 중복된다면? 
	이 경우에도 문제가 생긴다. 따라서 tcp는 출발지 IP주소, 출발지 포트번호, 도착지 IP주소, 도착지 포트번호를
	4-tuple이라고 묶고, 이 정보를 통해서 demultiplexing이 이루어진다.
	

	요약
		UDP : 플레인 요거트, 무옵션 차 같은 느낌
			UDP는 최선을 다 해서 데이터를 전송하긴 하지만 그러는 과정에서
			생기는 손실이나 문제에 대해서는 책임 x
		
		만약 UDP로 프로그램을 짜면 defensive coding을 할 일이 많다.
		즉 OS가 할 일을 프로그램이 하게 되는 것.
		이러한 특성 때문에 streaming multimedia apps, DNS, SNMP, HTTP/3 등에서 쓰인다.
		
	UDP의 헤더부분을 보면 출발지 포트, 도착지 포트, 길이, checksum이 있는데
	여기서 checksum은 뭐하는 애일까?
		패킷을 받는 라우터 입장에서 에러를 확인해야 한다.
		일단 에러가 뭘까?
			Errors may occur in delivering 페이지에서
			1은 파장이 길고, 0은 파장이 짧고 이건 physical layer에서 일어나는
			데이터 전달인데, 이 신호가 애매하면 라우터가 해석을 잘못할 수 있다.
			이렇게 잘못된 해석으로 비트가 뒤집히면 이런 것을 에러라고 한다.
		그렇다면 이걸 어떻게 알아낼까
		가장 기본적인 아이디어는 확인용으로 부가적인 정보를 같이 보내는 것이다.
		1의 개수가 홀수인지 짝수인지에 따라 만약 홀수이면 1을 붙이고, 짝수이면 0을 붙여서
		보낸다. 그리고 이 정보가 틀리면 flipped bit가 생긴 것. 

		하지만 이런 방식은 에러를 발견하지 못할 수도 있다. 
		이것을 해결하기 위해서 checksum을 쓴다. 
		원래 전송해야 할 데이터를 10진수로 바꿨을 때 5와 6이라고 하자.
		이때 이 둘의 합인 11을 붙여서 같이 보낸다. 
		그리고 데이터를 받은 후 다시 더해봤을 때 이 합과 다르다면 오류가 발생함을 인식한다.	
		<개념만 얘기하고 넘어간다고 하셨다>
		
	위 계층에서 내려오는 정보를 통으로 payload로 본다. 즉 위에서 추가한 헤더 부분들이 몸통으로
	들어간다는 뜻 같다. 따라서 제일 심하게 에러를 체크하는 것이 link layer이다. 위에서 쌓인
	헤더의 정보들을 모두 판단하기 때문.



★TCP
	TCP가 어떻게 손실을 방지하고 전송을 보장해주는 지 그 구조를 알아보겠다.
	
	Channel : 보내는 쪽과 받는 쪽의 링크같은 개념?? 
	채널이 reliable하면 좋지만 그렇지 않다.
	즉 데이터가 채널을 통과하는 과정에서 뭔가 문제가 생길 수 있다.
		여기서 문제란 bit error, loss, out of order 등이 있다.
	비트 에러의 경우 우리가 체크할 수 있지만 손실은 체크할 방법이 없다.
	그리고 순서도 어떻게 체크하며 어떻게 대응할 지를 배우겠다.

	tcp sender는 채널 상태와 리시버의 수신 여부를 아무것도 모른다. 
	따라서 sender 혼자 위 문제를 해결하는 건 말이 안되고, receiver와 프로토콜을 통해서 
	통신하여 이 문제를 풀어야 한다. 

	sender 가 channel 로 데이터를 보냈을 때 receiver는 데이터를 받았으면 sender에게 수신확인을 보낸다.
	잘 받았다 : ACK
	못 받았다 : NACK
	여기서 ACK에 대응하는 경우도 있고 NACK에 대응하는 경우도 있다.
	재전송 : sender가 channel로 데이터를 보낸 뒤 그 데이터를 버리면 안되고, 수신 확인 후
		데이터를 버리거나 재전송한다.
	sender가 수신확인을 계속해서 기다릴 수는 없다. 
	따라서 timeout을 두고 수신확인이 안오면 문제가 생겼다고 판단한다.

	TCP : Overview 파트 잘 보기
		빨간 부분 개념 이해/암기 하기

	point to point : 
		1 : 1 송수신관계여야 한다.
		IP 주소와 포트 번호로 길을 열고, 일대일 연결을 맺는다. 
	Stream of bytes service :
		바이트 덩어리를 순서에 맞춰서 receiver쪽으로 딱 옮겨주는 역할이 stream 형태로 이루어짐
	Reliable, in-order delivery 및 나머지는 ppt 참고

	tcp 헤더는 20바이트이다. 꼭 기억하라고 했음

	페이로드에는 위 계층에서 쌓여온 헤더들의 정보가 들어있다?
	또 헤더에 20이 붙어서 TCP/UDP는 총 40 바이트가 헤더에 소요된다.
	IP 헤더 20바이트, TCP/UDP 헤더 20바이트 이렇게 40바이트.
	
	바이트를 보낼 때 바이트를 하나씩 보내는 것이 아니라 블럭으로 묶어서 보낸다. 
	패킷의 한 길이가 1500바이트로 제한된다. 
	여기서 한 패킷에 들어갈 수 있는 내용물은 1460바이트로 제한된다. 
	MSS : Maximum Segment Size
		10MSS로 보낸다고 한다면 세그먼트 10개를 쓴다는 뜻.
		
	만약 MSS를 1000바이트로 조금 작게 잡는다고 치자.
		그럼 첫번째 세그먼트는 1-999, 두번째는 1000-1999 ... 이렇게 된다.
		여기서 sequence number는 세그먼트의 숫자를 따서 1, 2, 3...이렇게가 아니라
		시작 비트를 따서 0, 1000, 2000...이렇게 간다. 


	Initial Sequence Number(ISN)
		어떤 랜덤한 수를 처음 Sequence Number로 지정하고,
		그 뒤의 Sequence Number는 ISN에 앞에서 말한 시작 비트?를 더해준다. 

		ISN을 왜 0부터 하지 않고 랜덤으로 할까? 이건 숙제. 꼭 해와요~~

		Sequence Number는 Integer를 사용하므로 4바이트를 차지한다. 
		
	ACK 패킷. 앞에서 말한 수신확인용 패킷이다.
		이 패킷의 A 부분이 1이면 ACK이다.
		그리고 이 패킷의 크기는 40바이트이다. (왜???)

	piggybacked : 어부바. 데이터랑 ACK를 같이 보내고, 이 방식이 ACK만 보내는 것보다 효율적이다.
	
	만약 2번째 세그먼트(1000-1999)를 잘 받았다는 ack number는 어떻게 될까?
	다음 세그먼트의 Sequence Number인 2000이다.
	다음꺼 2000내놔라 정도로 해석하면 될 듯
	존나 중요 ★ 헷갈리지 말자

	cumulative ACK
	sender가 데이터를 10바이트씩 보내는 상황이다. 
	여기서 세번째 ACK를 잃어버리고 4번째 ACK가 잘 간다면
	누적개념으로 인해 3번째를 신경쓰지 않고 계속 진행한다.
	왜냐하면 데이터는 잘 갔는데 ack만 안 간 것이기 때문.
	ack 메시지에 손실이 있어도 견고한 전송이 가능하다
	
	TCP seq number 순서도는 캡쳐 참고
	그리고 1번 2번 3번

	Delayed ACK
	데이터랑 같이 갈려고 잠깐 기다렸다가 데이터가 오면 같이 감.
	piggyback을 위해서.
	이 경우 살짝 기다리는 것을 그래프에서 확인할 수 있다.

	Delayed ACK을 쓸 수 있는 최대 수는 1개이다. 두번째에서는 바로 그냥 ACK을 보낸다. 
	하나만 보낸다. 누적 ACK이기 때문에. 
	이로 인해 보내야되는 ACK의 수가 절반이 될 수도 있다. == 최적화 기법
	
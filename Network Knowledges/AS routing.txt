인터넷은 굉장히 방대하고 많은 수의 라우터가 있다.
그런데 하나하나 link state나 distance vector를 돌리는 건 말이 안된다. scalability문제 발생

autonomous system (AS)
자율 시스템 (또는 도메인)
ISP들이 하나의 AS일 수도 있고 ISP를 사용하는 서브넷 중 큰 것들도 하나의 AS일 수도 있다.
inter와 intra 차이 알고있지?

intra처럼 내부적으로 결정될 수 있는 패킷은 독단적으로 결정할 수 있지만(성남시 내부의 버스 노선 및 시간표)
inter와 같이 외부적으로 결정되어야 하는 패킷은 AS들 사이의 프로토콜의 협의가 필요하다(시와 시를 오가는 광역버스)

	인트라 AS 라우팅 프로토콜에는 LS, DV 기반으로 만들어진 프르토콜들을 쓸 수 있고 대표적으로 많이
	사용하는 프로토콜이 link state기반으로 된 OSPF, RIP 등이 있다.

	instra-AS routing은, 즉 내부에서 목적지를 찾는 라우팅의 목표는 최소의 cost로 목적기까지 가는
	shortest path를 찾는 것이다. 

	그리고 외부의 목적지로 이동하기 위해 필요한 외부의 정보는
	inter-AS routing protocol을 이용해서 정보를 교환한다.
	(옆에 있는 ISP들이 알려준다고 한다.)

	지금까지 우리가 공부한 LS, DV는 intra-AS Routing 프로토콜이었다.
	내부적으로는 길찾기를 최소의 비용으로 하는 것이 마땅하다.
	현재 사용되고 있는 가장 유명한 intra AS 알고리즘들은 알고있어야 한다.
	OSRF : 다익스트라와 LS 기반의 OSPF : Open Shortest-path First
		ㄴ 다익스트라 알고리즘을 쓴 link-state algorithm이다는 것을 꼭 기억하라고 함
	RIP : Routing information protocol
	EGRP : 풀네임 ppt 참고, 시스코에서 만듦
		RIP와 EGRP는 DV 기반의 알고리즘. 시험 각이다.

	OSPF : 처음에 정보를 얻기 위해 전체 AS내에서 라우터들에게 flood(broadcast)하고 topology 정보들이
	모이면 그때 다익스트라 알고리즘을 돌려서 경로를 최단으로 찾는다.

	뒤 피피티는 참고만.

/////////////////////////////////////////////////////////////////////////////////////////

BGP 프로토콜

	매우 중요한 내용.
	ISP 라우터들에게서 실전에서 쓰이는 프로토콜이 되겠다. 
	
	만약 AS1의 라우터 하나가 외부의 AS로 향하는 데이터그램을 받았으면 그 데이터그램이 어디로 가야되느지
	어떻게 알아야 할까?
	inter-AS 상에서 이 역할을 해줘야한다. 
		1. 외부 AS로 가기 위해 어디로 가야되는 지 알아오는 것
		2. 목적지를 알아왔으면 그 정보를 AS1의 내부에 모두 퍼트려줘야 함.
		3. 외부의 AS들에게도 AS1 내부의 정보를 퍼트려야 한다.
			ㄴ 만약 AS1 내부에 네이버의 ip가 있다면, "네이버로 갈려면 여기로 오세요" 하고 
			알려주어야 한다.
		BGP (Border Gateway Protocol)이 이 역할을 수행해준다. 
	
	BGP
		사실상 오늘날의 표준처럼 쓰인다.
		다른 인터넷에 있는 모든 부분으로 자신의 존재를 보낸다.(advertise its existence)

		exteranl BGP(eBGP) : 외부에서 정보를 얻어옴 (어느 방향으로 갈 지)
		internal BGP(iBGP) : 외부에서 얻어온 정보를 내부에 퍼뜨림
			관련 그림 ppt 참고

		외부와 연결된 부분은 게이트웨이 라우터이고, 이 부분에 대해서는 eBGP와 iBGP가 같이 운영된다.
		

	AS3와 연결된 X라는 서브넷으로 가기 위해서 다른 AS들은 X가 AS3와 연결되어 있다는 정보가 필요하고,
	AS3의 3a 게이트 웨이는 다른 AS들에게 eBGP의 session으로 AS3,X(AS3와 X가 연결됨) 이라는 정보를
	advertise한다. 
	그리고 이 말은 AS3는 이 정보를 보고 들어온 데이터그램을 X로 책임지고 포워딩 해주겠다는 의미도 담겨있다.
	그리고 만약 이 정보가 AS2를 거쳐 AS1에게 갔다면, 중간에 거친 AS2의 정보도 붙여서 AS2,AS3,X 와 같은
	형식으로 바뀌어야 한다.


	그리고 AS3와 연결의 관장하는 AS2의 게이트웨이는 이 advertise된 정보를 수락을 할 지 결정해야 한다. 
	그리고 AS3가 아닌 다른 AS와 연결된 AS2의 게이트웨이도 이 정보를 다른 AS에게 건네줄 지 결정해야 한다.
	(왜냐하면 AS3로 가기 위해서는 자신을 지나야하기 때문에)
	이런 결정들은 알고리즘이 아니라 전적으로 Policy, 즉 정책에 의해 결정된다고 한다.

	만약 AS1, AS2, AS3 3개의 AS가 있고 위 예시와 똑같이 AS3와 연결된 X의 정보를 advertise 한다고 가정하자
	AS2가 AS3와 서로 협력적인 계약을 했다고 하면  AS2는 AS3로부터 오는 정보를 모두 받아들이고 내부적으로 퍼뜨린 뒤
	다른 AS로 내보내준다.
	만약에 AS3과 AS1로 가는 어떤 간접적인? 경로가 있다고 하면 AS1의 게이트웨이 라우터 1c 입장에서는 2개의 선택지가
	생긴다. 이것도 정책에 따라 결정.

	inter-AS 와 intra-AS 왜 두개로 나눠서 다른 정책을 쓸까?
		policy는 각각의 ISP내에서 제어/관리를 하기 위한 목적이 있기 때문이다. 
		즉 inter-AS는 관리자가 트래픽, 혹은 회사의 이해관계 등을 관리하기 위해 그것이 주가 되는 policy를 사용한다.
	inter-AS와 intra-AS로 이원화되어있기 때문에 넓은 범위로 라우팅이 잘 적용될 수 있다.
	그리고 성능과 관련해서, intra-AS는 최적의 성능을 내기 위한 것이고
	inter-AS는 정책에 우선하기 위한 것이다.

	Hot potato routing
		우리 손에 뜨거운 감자가 있을 때 가능한 빨리 다른 사람에게 넘기고 싶을 것이다.
		내부적인 intra AS 프로토콜에서 OSPF같은 최적의 cost 기반으로 동작하는 라우팅 알고리즘이 쓰이고 있다고
		했을 때 가까운 egress 라우터로 보내서 그 데이터그램을 뜨거운 감자처럼 인식해서 빨리 내보내게 하는 것이다.
		
		만약 2d 라우터에게 X로 가는 2개의 길이 주어진다면, 이때 2d는 (뜨거운 감자)둘 중 더 코스트가 적은
		쪽으로 목적지를 설정한다.
		

	hot potato로 라우팅을 하면 최단경로가 아니라 더 긴 경로가 될 수도 있겠는데? 라고 생각할 수 있다.
	그렇다. 그렇기 때문에 hot potato는 자기 자신(AS)만 생각하는 selfish routing이다.
	(내부에서 이동하는 비용은 가장 적기 때문에)

	그리고 가는 길과 오는 길이 다를 수 있다. 3번 통로를 통해 나갔지만 1번 통로를 통해 들어올 수도 있기 때문에
	asymmetric routing이다. 

	BGP에서 어떤 정책이 있을 때 advertise를 통해서 특정한 정책을 어떻게 실현할까?
		<참고>
		ISP가 일반적으로 갖고있는 정책 중 하나는 만약 자신의 고객 네트워크를 경유하는 행위를 용납하지 않는다.
		왜냐하면 그렇게 될 경우 고객의 네트워크에 부하만 걸리고 이득은 없기 때문.

		29p. 
			B와 C라는 ISP가 있고, 이들은 각각 x와 y라는 고객이 있다. 
			x가 w로 가기 위해서 B,A,w라는 경로를 받았다. 
			이것은 문제가 없지만, 그렇다면 B는 C에게도 이 정보를 보내야 할까?
			보낼 필요가 없다. 이 정보를 보낼 경우 C애서 B를 거쳐 w로 가는 길이 열리고 B에게는 부하만 
			걸릴 뿐 이익이 없기 때문이다. 



======================================================================


ICMP 

	ICMP는 error reporting과 라우터들간의 정보 교환을 위해 사용되는 프로토콜
	패킷의 헤더쪽에 붙어서 이동한다.
	ICMP는 에러의 종류를 보고하거나 네트워크 상태를 측정하는데 사용된다. 
		네트워크 상태의 측정은 echo를 이용하면 가능한데, 이 ICMP가 echo에서 사용된다.
	ping도 이 echo 중 하나이다. I
		CMP echo request packet을 보내면 상대측에서 ICMP echo reply를 보낸다.
	
	TTL : Time to live (남아있는 수명)
	라우터들이 포워딩을 할 때 마다 TTL 값을 하나씩 빼버린다. 
	처음 TTL이 56이라면 하나의 라우터를 지날 때 마다 55, 54 ... 이렇게 줄어든다.
		즉 TTL은 몇 HOP 까지 갈 수 있는 전송 범위로 사용될 수 있다.
		그리고 TTL은 무한루프를 도는 패킷을 없애는 용도가 있다.

	ICMP는 TTL이 expire 됐다는 것을 상대방에게 바로 알린다. 
	이것으로 뭘 할 수 있냐면, 내 컴퓨터에서 특정한 IP 주소를 가진 목적지 까지 이동하는 경로를 추적할 수 있다.
	어떻게? 처음에 TTL을 1로 두고 보내면 바로 TTL이 만기됨과 동시에 그 라우터의 정보를 알 수 있다.
	다음으로 TTL을 2로 설정해서 보내면 또 마지막 라우터의 정보를 얻을 수 있다. 마찬가지로 3, 4, ... 이렇게 하나씩 늘려가면서 보내면
	목적지에 갈 때 까지의 경로를 추적할 수 있는 것이다.

	ICMP는 보안에 악용될 수 있다. 핑으로 목적지에 접근할 수 있는지 확인함.
	따라서 방화벽은 ICMP의 echo request packet을 off 시킨다.
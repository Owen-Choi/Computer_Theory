챕터 3은 너네한테 좀 어려울거임ㅋ 
그래서 4부터 할거니까 그렇게 알아라.
			- 최재혁 교수님

네트워크 레이어
	
	인터넷 프로토콜의 5개 레이어 : 
		application layer
		transport layer
		network layer
		link layer
		physical layer

		지금까지는 application layer를 공부했고 이제 network layer를 공부해보자.
		application layer가 중요했던 이유는 우리가 프로그램을 만들 때 지켜야 하는, 기존에 있는
		프로토콜을 지켜서 "잘 설계된" 프로그램을 만들어야 하기 때문에.
	
		인터넷 게임처럼 데이터 송수신이 많은 프로그램의 프로토콜은 텍스트 형식이 아니라
		영상처럼 코덱의 형식으로 송수신 하는 경우가 많다고 한다. 이건 나중에 설명해줄게 ㅋ

		네트워크 레이어에서 핵심이 되는 장비는 라우터이다.
		store and forward의 forward : 라우터는 forwarding table을 가지고 있다.
		이 포워딩 테이블은 IP주소를 기반으로 라우터들이 내보내야 되는 output link를 저장해두고 있다.
		
		여기서 포워딩 기능은 나중에 다시 공부할 예정이다.

	

	하나의 호스트는 최대 하나의 IP만을 가질 수 있을까? ==> 아니다.
	IP주소는 누구에게 할당이 됐을까? ==> 호스트에게 할당 된 것은 맞는데, 호스트의 어디?
					==> network interface card(NIC)에 할당된다.
					우리 컴퓨터에는 NIC가 적어도 2개는 있을 것이다. (와이파이, ....)
	사용자가 활성화 시켜놓은 NIC에 IP가 할당되게 된다. 
	라우터의 랜을 꼽는 랜포트 하나하나가 NIC이다. 즉 랜포트의 수 만큼 IP주소가 다 있는 것이다. 

	address는 주소를 얻는 것이고, addressing은 주소를 가지고 어떤 일련의 행동을 하는 것이다. 
	IP를 기반으로 패킷들이 제대로 목적지로 찾아가게 하는 것 정도로 addressing을 생각하면 될 듯.
	
	IP주소는 32bit 주소 체계를 쓰고, 한 바이트씩을 나눠서 (한 바이트는 0~255까지 표현가능)
	사이사이 점을 찍어 나타낸다.(dotted-quad notation)

	IPv4 : 32비트 체계를 사용, 총 2^32개까지 할당 가능한데, 이는 42억개 정도로 굉장히 부족한 수다.
	그런데 왜 IP주소가 부족하지 않은 것일까? ==> 뒤에서 공부한대.

	IP주소를 2진수로 바꿀 줄 알아야 한다. 반대로 바꿀 줄도 알아야 한다. 
	할 줄 알아야 한다고 거듭 말씀하신 걸 보면 시험에...?

	scalability challenge : 
		scalability : 확장성
		작은 사이즈의 Input에서는 잘 돌아가지만 엄청나게 큰 Input에서도 잘 동작하냐에 관한 것.
		여기서 얘기하고 싶은 건, 임의의 IP를 아무 규칙성 없이 호스트에게 할당을 할 경우 라우터가 
		패킷을 보고 목적지를 forwarding 해야하는데 scalability 문제가 없을까?

		최악의 경우 라우터의 forwarding table의 크기는 42억개가 되어야 한다.
		그렇다면 어떻게 포워딩 테이블이 너무 커지지 않고 효율적으로 IP주소들을 관리할 수 있을까?
		우편물을 예로 들면, 먼저 경상도로 갈 우편물들을 다 분리하고, 또 시로 가는 것들을 분리하고,
		.... 와 같이 계층 구조를 가진다. IP주소도 마찬가지이다.
		공통된 그룹정보 같은 느낌으로 IP주소를 할당하면 앞에 자리만 보고 그쪽 동네로 보내면 가니까
		그런 식으로 해보자 라는 것.
		==> 즉 hierarchical addressing
		우리가 32비트 IP주소를 바라볼 때 2개의 의미를 가지고 있다는 걸 알아야 한다.
		앞부분의 일정 길이는 호스트가 속한 네트워크에 할당된 주소이고, 나머지 뒷 부분은 
		그 네트워크 안에서 호스트 부분으로 생각을 해야한다.
		first x-bit prefix : 네트워크 주소 
		last 32-x bit : 호스트 주소

		12.34.158.0/24 : 32비트 주소 중에 앞의 24비트는 네트워크 주소를 말하는 거다.
		즉 앞의 점 3개까지는 네트워크 주소. 	-> ppt 참고

		ppt의 예시에서는 256개의 IP주소를 테이블 상에 한줄로 커버할 수 있다고 한다.
		이해가 잘 안되긴 하네. 뭔 말인진 알겠는데.
			==> 앞의 서브넷 파트가 동일해지기 때문에 그 한줄만 추가해놓으면 256개가
			갈 곳은 동일해지기 때문에 한줄로 축약 가능.
				==> ppt의 뒷부분에 예시가 있는데,wild card를 활용해서  범위를 정하고 그 범위에 속하면
					글로 보내버리는 식의 처리가 가능해지니 포워딩 테이블의 크기를 확 줄일 수 있다. 
				또한 새로운 IP주소가 들어오게 될 경우 포워딩 테이블을 업데이트할 필요가 없다.

		IP주소는 네트워크 주소 파트와 호스트 파트로 이루어져있고, 그 네트워크 주소 파트를
		서브넷 파트라고 생각하면 된다. 
		즉 네트워크 파트 == 서브넷 파트
		
		서브넷 : 같은 서브넷 파트를 가지고 있는 IP들은 같은 서브넷에 속한 것이다. 
		서브넷 주소는 223.1.1.0/24 와 같이 나타낸다.
		이 경우 최대 256개의 IP가 나오게 된다. (2^8, 앞의 비트들은 고정이고 마지막 0에 올 수 있는 경우의 수)
		
		
		CIDR : Classless InterDomain Routing
			예전에는 클래스가 있었다. 하지만 너무 복잡해서 서브넷파트, 호스트파트 2개로 나눴다.
			그것을 CIDR(사이다) 라고 한다. 

			서브넷에서 /24 처럼 명시해주는 것 말고 다른 표기법이 있다.
			바로 서브넷 마스크. 즉 서브넷 파트만 마스크로 바이너리 연산을 하고 호스트 파트는 그냥 놔두는 식.
			카톡 사진 참고, 255.254.0.0 의 서브넷 마스크는 111111.111110? 뭐 여튼 이런 식으로 된다고 한다....
			==> ppt 예제에서 12.4.0.0/15의 서브넷 마스크는 255.254.0.0이 된다. 여기서 두번째가 254인 이유는 서브넷의 prefix 길이가 
			15이기 때문이다. 비트가 1개 모자라기 때문?	그럼  만약 12.4.0.0/14면 서브넷 마스크는 어떻게 될까?
				==> 뭔소리하냐 철웅아. 비트로 치면 앞의 7자리가 1이고 마지막 한자리만 0이기 때문에
					256 - 1 = 255가 된다.
				
		정리 : 	우리는 CIDR 체계의 IP를 쓰고 있는데, 이는 IP는 서브넷파트(네트워크 파트), 호스트 파트로 나누는 것이다.
			이런 식의 체계를 쓸 경우 생기는 가장 큰 장점은 scalability가 증가한다. 교수님 빌드업 지림
			같은 서브넷은 같은 prefix를 가지기 때문에.

		255.255.255.0 의 서브넷 마스크 : 호스트는 최대 256개의 IP를 할당받는다.
		/24 와 동일

		만약 10개의 주소를 cover해야 한다면 10개보다 크고 가장 작은 2의 지수 수는 16이다.
		따라서 2^4만큼의 호스트가 필요하다. 따라서 서브넷 파트의 길이는 28bits가 된다.
		
		마찬가지로 200개의 주소를 커버할려면 2^8 만큼의 호스트가 필요하고, 서브넷의 prefix 길이는 24 bits이다.
		일반적으로 /24 를 가장 많이 쓴다고 한다. (참고)

		ICANN 이라는 기관이 전체적으로 IP, 인터넷의 코어, DNS 서버 등을 관리한다. (참고)

	DHCP : 

		how to bootstrap an end host : end host를 어떻게 활성화 시킬까?
		
		즉 컴퓨터를 처음 부팅할 때 로컬 dns 서버 주소와 NIC 등의 정보를 어떻게 알아와야 하나?
		호스트는 아이피 주소가 없고, 아이피 주소를 누구에게 물어봐야할 지 모른다. 
		(자동으로 IP주소를 받아오는 환경에서 IP주소를 뭘 쓸까 하는걸 알아와야 한다.)
		IP주소를 부트 후 우리가 직접 할당해도 되고 혹은 자동으로(DHCP) 할당받을 수 있다.

		DHCP : Dynamic Host Configuration Protocol
		동적 프로토콜. 
		
		누군가, 즉 다른 서버로부터 무슨 정보를 얻을려면 내 IP주소를 가지고 있어야 패킷 교환이 되는데,
		나는 현재 IP주소가 없다. 그럼 IP주소를 어디서 받아와야 하지? 에 관한 물음이 있다.
		이 물음에 대한 답은 도움을 줄 수 있는 아무 서버나 찾는다.	
			==> Broadcast : 127.0.0.1 처럼 special하게 정의된 주소처럼 모든 비트를 1로 바꾸면
			255.255.255.255가 되는데, 이것이 broadcast 이다. 그리고 이 메세지는 "모든 서버가 수신자" 라는 뜻이다.
			즉 IP주소를 255.255.255.255라고 해서 "나 IP주소 주세요~~" 라고 보내고, 메세지를 받은 대부분의 호스트들은 
			도움을 줄 수 없기에 이 정보를 버리지만 DHCP 서버는 이 도움에 반응을 한다.
		
			즉 DHCP 서버는 호스트의 도움에 반응하여 IP주소 할당에 대한 정보를 회신한다.
			이미 IP주소를 할당받은 호스트들은 이 회신 역시 무시하고 버리며, 최초에 도움을 요청한 호스트가 이에 반응한다.
			이 회신에는 IP주소, 마스크, 게이트웨이, 라우터, DNS 서버 등의 정보가 포함된다.
			lease time : 대여시간

		<추가내용>
		DHCP의 4단계 : 
			1. client broadcast "DHCP discover" msg
				"Is there a DHCP server out there?"
				태초에 클라이언트는 DHCP 서버를 찾기 위해 broadcast한다.
			2. DHCP server responses "DHCP offer" msg
				"I'm here! here's an IP address you can use!"
				DHCP서버는 DHCP offer로 응답한다.
			3. client broadcast IP address "DHCP request" msg
				"Thank you, I'll take that."
				DHCP가 있는 것을 확인한 클라이언트는 DHCP에게 IP주소 요청을 보낸다.
			4. DHCP server responses "ACK" msg
				"Ok, you've got that IP address!"
				

		각 단계에 따른 아이피 주소 변화 양상

		DHCP discover : 
			source : 0.0.0.0 / 68 : 여기서 68은 자신의 포트.
			destination : 255.255.255.255 / 67 : 모두 255인 아이피는 broadcast 전용 IP, 즉 "아무나 받아라"의 의미.
			yiaddr : 0.0.0.0
	
		DHCP offer : 
			source : (DHCP ip)
			destination : 255.255.255.255 / 68
			yiaddr : (할당 or itself)
			lifetime 3600s (lifetime은 여기서부터 존재)

		DHCP request : 
			source : 0.0.0.0 / 68
			destination : 255.255.255.255 / 67
			yiaddr : offer에서 준 인터넷 주소 
			
	
		DHCP ACK : 
			source : 예제에서는 yiaddr에서 호스트 파트의 값이 하나만 달라져있다. 여튼 여기서부터 할당받음 
			destination : 255.255.255.255, 68
			나머지 다 동일

		==> 어쨌든 destination은 전부 broadcast이다. 

			예외상황 : 서브넷에 2개 이상의 DHCP가 있을 수 있고, 반대로 도움을 요청하는 호스트가 동시에 2명이 될 수도 있다.
			이런 상황에도 잘 돌아가는 체계를 구축하고싶다. 

			어떤 서브넷에서 DHCP 서버가 돌아가고 있다.
			이때 어떤 호스트가 처음 들어와서 DHCP에게 브로드케스트, 즉 목적지 주소를 255.255.255.255, 포트는 67(DHCP 지정 포트)
			로 지정하여 request?를 보낸다. (DHCP discover)
			여기서 DHCP는 두개 이상의 호스트에 대비해서 랜덤하게 난수 하나를 넣어서(transaction id) response를 보낸다
			


			DHCP는 UDP를 쓴다. 참고로 DNS도 UDP를 쓴다고 한다.